#!/bin/bash
# Superuser Terminal Script
# Version: 1.0-prototype
# This script provides enhanced functionality for managing superuser access on Android devices.

set -e # Enable strict error handling
# Note: set -u removed to avoid issues with uninitialized variables in conditional checks

# Security hardening - validate execution environment
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    echo "Error: Script must be executed directly, not sourced" >&2
    return 1 2>/dev/null || exit 1
fi

# Input validation function
validate_input() {
    local input="$1"
    local type="${2:-general}"
    
    case "$type" in
        "path")
            if [[ ! "$input" =~ ^[a-zA-Z0-9/_.-]+$ ]]; then
                echo "Error: Invalid path characters detected" >&2
                return 1
            fi
            ;;
        "command")
            if [[ "$input" =~ [;&|`$] ]]; then
                echo "Error: Dangerous command characters detected" >&2
                return 1
            fi
            ;;
        "numeric")
            if [[ ! "$input" =~ ^[0-9]+$ ]]; then
                echo "Error: Non-numeric input detected" >&2
                return 1
            fi
            ;;
    esac
    return 0
}

# Initialize default values for command line arguments with validation
if [[ $# -gt 0 ]]; then
    validate_input "$1" "command" || exit 1
fi
: "${1:=""}"

# Enhanced root check with secure elevation
secure_root_check() {
    if [ "$(id -u)" -ne 0 ]; then
        echo "This script must be run as root." >&2
        echo "Attempting secure root elevation..."
        
        # Validate su binary before use
        local su_binary=""
        for potential_su in "/system/bin/su" "/system/xbin/su" "/su/bin/su"; do
            if [[ -f "$potential_su" && -x "$potential_su" ]]; then
                # Additional security check - verify it's a legitimate su binary
                if file "$potential_su" 2>/dev/null | grep -q "executable"; then
                    su_binary="$potential_su"
                    break
                fi
            fi
        done
        
        if [[ -n "$su_binary" ]]; then
            # Secure execution with argument validation
            local safe_args=""
            for arg in "$@"; do
                validate_input "$arg" "command" || exit 1
                safe_args="$safe_args '$arg'"
            done
            exec "$su_binary" -c "$(printf '%q' "$0") $safe_args"
        else
            echo "Error: No valid su binary found" >&2
            exit 1
        fi
    fi
}

# Call secure root check
secure_root_check "$@"

# Confirm root access
echo "Root access confirmed (UID: $(id -u))"

# Version and branding
VERSION="1.0-prototype"
BRAND_NAME="Enhanced Superuser Terminal"

# Logging
LOG_DIR="/data/local/tmp/superuser_logs"
LOG_FILE="$LOG_DIR/superuser_install.log"
MAX_LOGS=12
mkdir -p "$LOG_DIR"

# Enhanced logging function with error handling
log() {
    local level="${1:-INFO}"
    shift || true
    local message="${*:-No message provided}"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown-time")
    
    # Ensure log directory exists
    if [ ! -d "$LOG_DIR" ]; then
        mkdir -p "$LOG_DIR" 2>/dev/null || {
            echo "Warning: Could not create log directory $LOG_DIR" >&2
            return 1
        }
    fi
    
    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE" 2>/dev/null || {
        echo "[$timestamp] [$level] $message"
        echo "Warning: Could not write to log file $LOG_FILE" >&2
    }
}

# Rotate logs if needed
if [ $(ls "$LOG_DIR"/*.log 2>/dev/null | wc -l) -ge $MAX_LOGS ]; then
    rm "$(ls -t "$LOG_DIR"/*.log | tail -1)"
fi

# Improved color array (declare -A for associative array)
declare -A COLORS=(
    [RED]='\033[0;31m'
    [GREEN]='\033[0;32m'
    [CYAN]='\033[0;36m'
    [YELLOW]='\033[1;33m'
    [BLUE]='\033[0;34m'
    [PURPLE]='\033[0;35m'
    [NC]='\033[0m'
)

# Enhanced dependency checker
check_dependencies() {
    echo -e "${COLORS[CYAN]}Checking system dependencies...${COLORS[NC]}"
    log "INFO" "Starting dependency check"
    
    local missing_deps=()
    local required_commands=("stat" "chmod" "chown" "mkdir" "grep" "awk" "date")
    local optional_commands=("file" "timeout" "getenforce")
    
    # Check required commands
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing_deps+=("$cmd")
            echo -e "${COLORS[RED]}✗${COLORS[NC]} Missing required command: $cmd"
        else
            echo -e "${COLORS[GREEN]}✓${COLORS[NC]} Found: $cmd"
        fi
    done
    
    # Check optional commands
    for cmd in "${optional_commands[@]}"; do
        if command -v "$cmd" >/dev/null 2>&1; then
            echo -e "${COLORS[GREEN]}✓${COLORS[NC]} Found (optional): $cmd"
        else
            echo -e "${COLORS[YELLOW]}!${COLORS[NC]} Missing (optional): $cmd"
        fi
    done
    
    # Attempt to install missing dependencies
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo -e "${COLORS[YELLOW]}Attempting to install missing dependencies...${COLORS[NC]}"
        if command -v busybox >/dev/null 2>&1; then
            echo -e "${COLORS[GREEN]}BusyBox detected - using built-in commands${COLORS[NC]}"
            # Create symlinks for missing commands if busybox is available
            for dep in "${missing_deps[@]}"; do
                if busybox "$dep" --help >/dev/null 2>&1; then
                    ln -sf "$(which busybox)" "/system/bin/$dep" 2>/dev/null || true
                fi
            done
        else
            echo -e "${COLORS[RED]}Critical dependencies missing and no BusyBox available${COLORS[NC]}"
            log "ERROR" "Missing critical dependencies: ${missing_deps[*]}"
            return 1
        fi
    fi
    
    echo -e "${COLORS[GREEN]}Dependency check completed${COLORS[NC]}"
    log "INFO" "Dependency check completed"
    return 0
}

# System information check
check_system_info() {
    echo -e "${COLORS[CYAN]}System Information Check:${COLORS[NC]}"
    log "INFO" "Starting system information check"
    
    # Enhanced Android version detection with multiple sources
    local android_version="Unknown"
    local api_level="Unknown"
    
    # Try multiple sources for Android version
    if [[ -f "/system/build.prop" ]]; then
        android_version=$(grep "ro.build.version.release" /system/build.prop 2>/dev/null | cut -d'=' -f2 | head -1 || echo "Unknown")
        api_level=$(grep "ro.build.version.sdk" /system/build.prop 2>/dev/null | cut -d'=' -f2 | head -1 || echo "Unknown")
    elif [[ -f "/vendor/build.prop" ]]; then
        android_version=$(grep "ro.vendor.build.version.release" /vendor/build.prop 2>/dev/null | cut -d'=' -f2 | head -1 || echo "Unknown")
    fi
    
    # Validate extracted values
    if [[ "$api_level" =~ ^[0-9]+$ ]]; then
        validate_input "$api_level" "numeric" || api_level="Unknown"
    fi
    
    echo -e "${COLORS[GREEN]}Android Version: $android_version (API $api_level)${COLORS[NC]}"
    log "INFO" "Android Version: $android_version (API $api_level)"
    
    # Enhanced architecture detection
    arch=$(uname -m 2>/dev/null || echo "unknown")
    local cpu_abi=""
    if [[ -f "/system/build.prop" ]]; then
        cpu_abi=$(grep "ro.product.cpu.abi=" /system/build.prop 2>/dev/null | cut -d'=' -f2 || echo "")
    fi
    
    echo -e "${COLORS[GREEN]}Architecture: $arch${COLORS[NC]}"
    if [[ -n "$cpu_abi" ]]; then
        echo -e "${COLORS[GREEN]}CPU ABI: $cpu_abi${COLORS[NC]}"
        log "INFO" "Architecture: $arch, CPU ABI: $cpu_abi"
    else
        log "INFO" "Architecture: $arch"
    fi
    
    # Check available space with error handling
    if available_space=$(df /data 2>/dev/null | tail -1 | awk '{print $4}'); then
        echo -e "${COLORS[GREEN]}Available space in /data: ${available_space}KB${COLORS[NC]}"
        log "INFO" "Available space in /data: ${available_space}KB"
    else
        echo -e "${COLORS[YELLOW]}Warning: Could not check available space in /data${COLORS[NC]}"
        log "WARN" "Could not check /data space"
    fi
    
    # Check SELinux status
    if command -v getenforce >/dev/null 2>&1; then
        selinux_status=$(getenforce 2>/dev/null || echo "Unknown")
        echo -e "${COLORS[YELLOW]}SELinux Status: $selinux_status${COLORS[NC]}"
        log "INFO" "SELinux Status: $selinux_status"
    else
        echo -e "${COLORS[YELLOW]}SELinux tools not available${COLORS[NC]}"
        log "INFO" "SELinux tools not available"
    fi
}

# Enhanced device compatibility check
check_device_compatibility() {
    echo -e "${COLORS[CYAN]}Device Compatibility Check:${COLORS[NC]}"
    log "INFO" "Starting device compatibility check"
    
    local compatibility_score=0
    local total_checks=0
    
    # Check for root access indicators
    local root_indicators=(
        "/system/app/Superuser.apk"
        "/system/etc/init.d"
        "/system/bin/busybox"
        "/data/local/tmp"
    )
    
    for indicator in "${root_indicators[@]}"; do
        ((total_checks++))
        if [ -e "$indicator" ]; then
            echo -e "${COLORS[GREEN]}✓${COLORS[NC]} Found: $indicator"
            ((compatibility_score++))
        else
            echo -e "${COLORS[RED]}✗${COLORS[NC]} Missing: $indicator"
        fi
    done
    
    # Calculate compatibility percentage
    local compatibility_percent=$((compatibility_score * 100 / total_checks))
    echo -e "${COLORS[BLUE]}Compatibility Score: $compatibility_percent%${COLORS[NC]}"
    log "INFO" "Device compatibility score: $compatibility_percent%"
    
    if [ $compatibility_percent -lt 50 ]; then
        echo -e "${COLORS[RED]}Warning: Low compatibility detected. Proceed with caution.${COLORS[NC]}"
        log "WARN" "Low compatibility detected"
    fi
}

# List of su binary locations
SU_PATHS=(
    "/system/bin/su" "/system/xbin/su" "/sbin/su" "/su/bin/su" "/su/xbin/su" "/system/sbin/su" "/magisk/.core/bin/su" "/debug_ramdisk/su" "/sbin/bin/su" "/system/su" "/system/xbin/daemonsu" "/system/xbin/busybox" "/su" "/xbin/su" "/bin/su" "/0/su"
)

# Setup root superuser directories and permissions
setup_root_superuser() {
    local root_dirs=(
        "/data/superuser"
        "/data/superuser/bin"
        "/data/superuser/etc"
        "/data/superuser/lib"
        "/data/superuser/tmp"
    )
    for dir in "${root_dirs[@]}"; do
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir"
            echo -e "${COLORS[YELLOW]}Created $dir${COLORS[NC]}"
        fi
        chmod 700 "$dir"
        chown root:root "$dir"
    done
    cat > /data/superuser/etc/profile << EOF
export PATH="/data/superuser/bin:$PATH"
export SUPERUSER_HOME="/data/superuser"
PS1='root@superuser:\w# '
EOF
}

# Enhanced su permissions fix with safety checks
fix_su_permissions() {
    echo -e "${COLORS[CYAN]}Fixing su binary permissions...${COLORS[NC]}"
    log "INFO" "Starting su permissions fix"
    
    local fixed_count=0
    local total_found=0
    local failed_paths=()
    
    for su_path in "${SU_PATHS[@]}"; do
        # Validate path before processing
        validate_input "$su_path" "path" || continue
        
        if [[ -f "$su_path" ]]; then
            ((total_found++))
            
            # Enhanced safety checks
            local file_type=""
            if command -v file >/dev/null 2>&1; then
                file_type=$(file "$su_path" 2>/dev/null || echo "")
            fi
            
            # Verify it's an executable and not a script
            if [[ "$file_type" =~ (executable|ELF) ]] || [[ -x "$su_path" ]]; then
                # Create timestamped backup
                local backup_dir="/data/superuser/backup"
                mkdir -p "$backup_dir" 2>/dev/null || {
                    log "WARN" "Could not create backup directory"
                    continue
                }
                
                local backup_name="$backup_dir/$(basename "$su_path").backup.$(date +%s)"
                if cp "$su_path" "$backup_name" 2>/dev/null; then
                    log "INFO" "Created backup: $backup_name"
                else
                    log "WARN" "Could not create backup for $su_path"
                fi
                
                # Apply permissions with error handling
                local success=true
                chmod 6755 "$su_path" 2>/dev/null || {
                    echo -e "${COLORS[RED]}Failed to set permissions for $su_path${COLORS[NC]}"
                    log "ERROR" "chmod failed for $su_path"
                    failed_paths+=("$su_path")
                    success=false
                }
                
                chown root:root "$su_path" 2>/dev/null || {
                    echo -e "${COLORS[RED]}Failed to set ownership for $su_path${COLORS[NC]}"
                    log "ERROR" "chown failed for $su_path"
                    if [[ "$success" == "true" ]]; then
                        failed_paths+=("$su_path")
                        success=false
                    fi
                }
                
                if [[ "$success" == "true" ]]; then
                    echo -e "${COLORS[GREEN]}Fixed permissions for $su_path${COLORS[NC]}"
                    log "INFO" "Fixed permissions for $su_path"
                    ((fixed_count++))
                fi
            else
                echo -e "${COLORS[YELLOW]}Skipping $su_path (not a valid executable)${COLORS[NC]}"
                log "WARN" "Skipped $su_path - not a valid executable"
            fi
        fi
    done
    
    echo -e "${COLORS[BLUE]}Summary: Fixed $fixed_count out of $total_found su binaries${COLORS[NC]}"
    log "INFO" "Su permissions fix completed: $fixed_count/$total_found"
    
    # Report failures and suggest recovery
    if [[ ${#failed_paths[@]} -gt 0 ]]; then
        echo -e "${COLORS[YELLOW]}Failed to fix permissions for:${COLORS[NC]}"
        for path in "${failed_paths[@]}"; do
            echo -e "${COLORS[RED]}  - $path${COLORS[NC]}"
        done
        echo -e "${COLORS[CYAN]}Recovery suggestions:${COLORS[NC]}"
        echo "  - Check if filesystem is mounted read-only"
        echo "  - Verify SELinux policy allows modifications"
        echo "  - Ensure sufficient disk space"
        return 1
    fi
    
    return 0
}

# Enhanced backup function
backup_critical_files() {
    echo -e "${COLORS[CYAN]}Creating backup of critical files...${COLORS[NC]}"
    local backup_dir="/data/superuser/backup/$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"
    
    for su_path in "${SU_PATHS[@]}"; do
        if [ -f "$su_path" ]; then
            cp "$su_path" "$backup_dir/" 2>/dev/null && \
            echo -e "${COLORS[GREEN]}Backed up: $su_path${COLORS[NC]}" || \
            echo -e "${COLORS[RED]}Failed to backup: $su_path${COLORS[NC]}"
        fi
    done
    
    echo -e "${COLORS[BLUE]}Backup location: $backup_dir${COLORS[NC]}"
    log "INFO" "Backup created at: $backup_dir"
}

# Improved accessibility check: also test execution
check_accessibility() {
    echo -e "${COLORS[CYAN]}\nAccessibility Check Summary:${COLORS[NC]}"
    log "INFO" "Starting accessibility check"
    local all_ok=1
    local found_count=0
    local working_count=0
    local issues=()
    
    for su_path in "${SU_PATHS[@]}"; do
        validate_input "$su_path" "path" || continue
        
        if [[ -f "$su_path" ]]; then
            ((found_count++))
            local perms=$(stat -c %a "$su_path" 2>/dev/null || echo "000")
            local owner=$(stat -c %U "$su_path" 2>/dev/null || echo "unknown")
            local group=$(stat -c %G "$su_path" 2>/dev/null || echo "unknown")
            
            if [[ "$perms" == "6755" && "$owner" == "root" && "$group" == "root" ]]; then
                # Enhanced executable test with timeout and error capture
                local test_result=""
                if command -v timeout >/dev/null 2>&1; then
                    test_result=$(timeout 5 "$su_path" --version 2>&1 || timeout 5 "$su_path" -c "id" 2>&1 || echo "failed")
                else
                    # Fallback without timeout
                    test_result=$("$su_path" --version 2>&1 || "$su_path" -c "id" 2>&1 || echo "failed")
                fi
                
                if [[ "$test_result" != "failed" && ! "$test_result" =~ (not found|denied|invalid) ]]; then
                    echo -e "${COLORS[GREEN]}OK${COLORS[NC]} $su_path (6755 root:root, executable)"
                    ((working_count++))
                    log "INFO" "Su binary working: $su_path"
                else
                    echo -e "${COLORS[YELLOW]}WARN${COLORS[NC]} $su_path (permissions OK, execution failed: ${test_result:0:50})"
                    issues+=("$su_path: execution failed")
                    all_ok=0
                    log "WARN" "Su binary not executable: $su_path - $test_result"
                fi
            else
                echo -e "${COLORS[RED]}BAD${COLORS[NC]} $su_path (perms: $perms, owner: $owner:$group)"
                issues+=("$su_path: incorrect permissions/ownership")
                all_ok=0
                log "ERROR" "Su binary bad permissions: $su_path"
            fi
        fi
    done
    
    echo -e "${COLORS[BLUE]}Summary: Found $found_count su binaries, $working_count working${COLORS[NC]}"
    
    # Check root superuser dir
    if [ -d "/data/superuser" ]; then
        perms=$(stat -c %a /data/superuser)
        owner=$(stat -c %U /data/superuser)
        group=$(stat -c %G /data/superuser)
        if [ "$perms" = "700" ] && [ "$owner" = "root" ] && [ "$group" = "root" ]; then
            echo -e "${COLORS[GREEN]}OK${COLORS[NC]} /data/superuser (700 root:root)"
        else
            echo -e "${COLORS[RED]}BAD${COLORS[NC]} /data/superuser (perms: $perms, owner: $owner:$group)"
            all_ok=0
        fi
    else
        echo -e "${COLORS[RED]}MISSING${COLORS[NC]} /data/superuser"
        all_ok=0
    fi
    
    # Enhanced diagnostics for issues
    if [[ ${#issues[@]} -gt 0 ]]; then
        echo -e "${COLORS[YELLOW]}Detected Issues:${COLORS[NC]}"
        for issue in "${issues[@]}"; do
            echo -e "${COLORS[RED]}  - $issue${COLORS[NC]}"
        done
        echo -e "${COLORS[CYAN]}Troubleshooting suggestions:${COLORS[NC]}"
        echo "  - Run 'setenforce 0' to temporarily disable SELinux"
        echo "  - Check mount options: 'mount | grep system'"
        echo "  - Verify root access: 'id'"
        echo "  - Check for Magisk/SuperSU conflicts"
    fi
    
    if [[ $all_ok -eq 1 ]]; then
        echo -e "${COLORS[GREEN]}All checks passed!${COLORS[NC]}"
        log "INFO" "All accessibility checks passed"
    else
        echo -e "${COLORS[RED]}Some issues detected. Please review above.${COLORS[NC]}"
        log "ERROR" "Accessibility check failed"
    fi
    
    return $all_ok
}

# Auto-install adb if missing
install_adb_if_missing() {
    if ! command -v adb >/dev/null 2>&1; then
        echo -e "${COLORS[YELLOW]}adb not found. Attempting to install Android Platform Tools...${COLORS[NC]}"
        if command -v apt-get >/dev/null 2>&1; then
            apt-get update && apt-get install -y android-tools-adb && echo -e "${COLORS[GREEN]}adb installed.${COLORS[NC]}"
        elif command -v yum >/dev/null 2>&1; then
            yum install -y android-tools && echo -e "${COLORS[GREEN]}adb installed.${COLORS[NC]}"
        else
            echo -e "${COLORS[RED]}Could not auto-install adb. Please install it manually.${COLORS[NC]}"
        fi
    fi
}

# Android command terminal function
android_cmd_terminal() {
    install_adb_if_missing
    echo -e "${COLORS[CYAN]}Launching Android command terminal...${COLORS[NC]}"
    if ! command -v adb >/dev/null 2>&1; then
        echo -e "${COLORS[RED]}adb not found. Please install Android Platform Tools.${COLORS[NC]}"
        return 1
    fi
    adb start-server >/dev/null 2>&1
    adb shell || {
        echo -e "${COLORS[RED]}Failed to open adb shell. Is your device connected and authorized?${COLORS[NC]}"
        return 1
    }
}

# Android user account and id info
android_user_info() {
    install_adb_if_missing
    echo -e "${COLORS[CYAN]}Android User Account & ID Info:${COLORS[NC]}"
    if ! command -v adb >/dev/null 2>&1; then
        echo -e "${COLORS[RED]}adb not found. Please install Android Platform Tools.${COLORS[NC]}"
        return 1
    fi
    adb start-server >/dev/null 2>&1
    adb shell 'pm list users; id; whoami; getprop persist.sys.device_name; getprop ro.product.model; getprop ro.serialno' 2>/dev/null || {
        echo -e "${COLORS[RED]}Failed to retrieve user info. Is your device connected and authorized?${COLORS[NC]}"
        return 1
    }
}

# Auto-configure sudo/root superuser if possible
auto_configure_sudo() {
    echo -e "${COLORS[CYAN]}Checking sudo/root superuser configuration...${COLORS[NC]}"
    # Check if sudo is installed
    if ! command -v sudo >/dev/null 2>&1; then
        echo -e "${COLORS[YELLOW]}sudo not found. Attempting to install...${COLORS[NC]}"
        if command -v apt-get >/dev/null 2>&1; then
            apt-get update && apt-get install -y sudo && echo -e "${COLORS[GREEN]}sudo installed.${COLORS[NC]}"
        elif command -v yum >/dev/null 2>&1; then
            yum install -y sudo && echo -e "${COLORS[GREEN]}sudo installed.${COLORS[NC]}"
        else
            echo -e "${COLORS[RED]}Could not auto-install sudo. Please install it manually.${COLORS[NC]}"
        fi
    else
        echo -e "${COLORS[GREEN]}sudo is present.${COLORS[NC]}"
    fi
    # Ensure current user is in sudoers if not root
    if [ "$(id -u)" -ne 0 ]; then
        user=$(whoami)
        if sudo -l -U "$user" | grep -q '(ALL) ALL'; then
            echo -e "${COLORS[GREEN]}$user already has sudo privileges.${COLORS[NC]}"
        else
            echo -e "${COLORS[YELLOW]}$user does not have sudo privileges. Attempting to add...${COLORS[NC]}"
            echo "$user ALL=(ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/$user >/dev/null && \
            echo -e "${COLORS[GREEN]}$user added to sudoers (NOPASSWD).${COLORS[NC]}"
        fi
    fi
}

# Test sudo/root superuser access
check_sudo_root_access() {
    echo -e "${COLORS[CYAN]}Testing sudo/root superuser access...${COLORS[NC]}"
    if [ "$(id -u)" -eq 0 ]; then
        echo -e "${COLORS[GREEN]}Already running as root.${COLORS[NC]}"
    else
        if sudo -n true 2>/dev/null; then
            echo -e "${COLORS[GREEN]}Sudo access confirmed for $(whoami).${COLORS[NC]}"
        else
            echo -e "${COLORS[RED]}Sudo access failed for $(whoami).${COLORS[NC]}"
        fi
    fi
}

# Interactive menu
interactive_mode() {
    while true; do
        echo -e "\n${COLORS[PURPLE]}=== $BRAND_NAME v$VERSION ===${COLORS[NC]}"
        echo "1. Run full system check"
        echo "2. Fix su permissions"
        echo "3. Android command terminal"
        echo "4. Android user info"
        echo "5. Create backup"
        echo "6. View logs"
        echo "7. Exit"
        echo -n "Select option [1-7]: "
        read -r choice
        
        case $choice in
            1)
                check_system_info
                check_device_compatibility
                setup_root_superuser
                fix_su_permissions
                check_accessibility
                ;;
            2)
                fix_su_permissions
                check_accessibility
                ;;
            3)
                android_cmd_terminal
                ;;
            4)
                android_user_info
                ;;
            5)
                backup_critical_files
                ;;
            6)
                echo -e "${COLORS[CYAN]}Recent log entries:${COLORS[NC]}"
                tail -20 "$LOG_FILE" 2>/dev/null || echo "No logs found"
                ;;
            7)
                echo -e "${COLORS[GREEN]}Goodbye!${COLORS[NC]}"
                break
                ;;
            *)
                echo -e "${COLORS[RED]}Invalid option. Please try again.${COLORS[NC]}"
                ;;
        esac
    done
}

# Enhanced main function with comprehensive error handling
main() {
    echo -e "${COLORS[CYAN]}$BRAND_NAME v$VERSION${COLORS[NC]}"
    log "INFO" "Starting Enhanced Superuser Terminal v$VERSION"
    
    # Pre-flight checks
    if ! check_dependencies; then
        echo -e "${COLORS[RED]}Critical dependency check failed${COLORS[NC]}"
        exit 1
    fi
    
    # Validate environment with enhanced checks
    local validation_errors=()
    
    if [[ ! -w "/data" ]]; then
        validation_errors+=("/data directory is not writable")
    fi
    
    if [[ ! -d "/system" ]]; then
        validation_errors+=("/system directory not found - may not be Android")
    fi
    
    # Check available disk space (require at least 10MB)
    local available_kb=$(df /data 2>/dev/null | tail -1 | awk '{print $4}' || echo "0")
    if [[ "$available_kb" -lt 10240 ]]; then
        validation_errors+=("Insufficient disk space (need 10MB, have ${available_kb}KB)")
    fi
    
    if [[ ${#validation_errors[@]} -gt 0 ]]; then
        echo -e "${COLORS[RED]}Environment validation failed:${COLORS[NC]}"
        for error in "${validation_errors[@]}"; do
            echo -e "${COLORS[RED]}  - $error${COLORS[NC]}"
            log "ERROR" "$error"
        done
        exit 1
    fi
    
    # Check if running interactively
    if [[ "$1" == "interactive" || "$1" == "-i" ]]; then
        interactive_mode
        return 0
    fi
    
    # Run system checks first
    check_system_info || log "WARN" "System info check had issues"
    check_device_compatibility || log "WARN" "Device compatibility check had issues"
    
    # Original functionality with enhanced error handling
    auto_configure_sudo || log "WARN" "sudo configuration failed"
    check_sudo_root_access || log "WARN" "sudo access check failed"
    setup_root_superuser || {
        log "ERROR" "root superuser setup failed"
        echo -e "${COLORS[RED]}Failed to setup root superuser environment${COLORS[NC]}"
        return 1
    }
    
    fix_su_permissions || {
        log "ERROR" "su permissions fix failed"
        echo -e "${COLORS[YELLOW]}Some permission fixes failed - system may be partially functional${COLORS[NC]}"
    }
    
    check_accessibility || log "WARN" "accessibility check had issues"
    
    # Handle command line arguments with validation
    local command="${1:-check}"
    validate_input "$command" "command" || {
        echo -e "${COLORS[RED]}Invalid command specified${COLORS[NC]}"
        exit 1
    }
    
    case "$command" in
        "android-term")
            android_cmd_terminal || {
                log "ERROR" "Android terminal launch failed"
                return 1
            }
            ;;
        "android-user")
            android_user_info || {
                log "ERROR" "Android user info retrieval failed"
                return 1
            }
            ;;
        "backup")
            backup_critical_files || {
                log "ERROR" "Backup creation failed"
                return 1
            }
            ;;
        "check")
            echo -e "${COLORS[GREEN]}Full system check completed. Check logs for details.${COLORS[NC]}"
            ;;
        *)
            echo -e "${COLORS[BLUE]}Available options:${COLORS[NC]}"
            echo "  android-term  - Launch Android terminal"
            echo "  android-user  - Show Android user info"
            echo "  backup       - Create backup of critical files"
            echo "  check        - Run full system check (default)"
            echo "  interactive  - Launch interactive mode"
            ;;
    esac
    
    log "INFO" "Enhanced Superuser Terminal session completed successfully"
    return 0
}

# Execute main function with comprehensive error handling
if ! main "$@"; then
    echo -e "${COLORS[RED]}Script execution failed. Check logs for details.${COLORS[NC]}" >&2
    log "ERROR" "Script execution failed"
    exit 1
fi