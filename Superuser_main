#!/bin/bash
# Superuser Terminal Script
# Version: 1.1-enhanced
# This script provides enhanced functionality for managing superuser access on Android devices.

set -euo pipefail

# Performance optimization - enable parallel execution where safe
export PARALLEL_JOBS="${PARALLEL_JOBS:-4}"

# Enhanced error handling with stack traces
set -E
trap 'error_handler $? $LINENO $BASH_LINENO "$BASH_COMMAND" $(printf "%s " "${FUNCNAME[@]}")' ERR

error_handler() {
    local exit_code=$1
    local line_no=$2
    local bash_lineno=$3
    local last_command=$4
    local func_stack=("${@:5}")
    
    echo "Error occurred in script execution:" >&2
    echo "  Exit code: $exit_code" >&2
    echo "  Line: $line_no" >&2
    echo "  Command: $last_command" >&2
    echo "  Function stack: ${func_stack[*]}" >&2
    
    # Log error details if logging function is available
    if declare -f log >/dev/null 2>&1; then
        log "FATAL" "Script error at line $line_no: $last_command (exit code: $exit_code)"
    fi
    
    # Cleanup on error
    cleanup_on_error
    
    exit $exit_code
}

# Cleanup function for error scenarios
cleanup_on_error() {
    # Kill background processes if any
    jobs -p | xargs -r kill 2>/dev/null || true
    
    # Remove temporary files
    rm -f /tmp/superuser_temp_* 2>/dev/null || true
    
    echo "Cleanup completed after error" >&2
}

# Security hardening - validate execution environment
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    echo "Error: Script must be executed directly, not sourced" >&2
    return 1 2>/dev/null || exit 1
fi

# Input validation function
validate_input() {
    local input="$1"
    local type="${2:-general}"
    
    if [[ -z "$input" ]]; then
        echo "Error: Input cannot be empty" >&2
        return 1
    fi
    
    case "$type" in
        "path")
            if [[ "$input" =~ ^[a-zA-Z0-9/_.-]+$ ]]; then
                return 0
            else
                echo "Error: Invalid path characters detected" >&2
                return 1
            fi
            ;;
        "command")
            if ! [[ "$input" =~ [;&|`$] ]]; then
                return 0
            else
                echo "Error: Dangerous command characters detected" >&2
                return 1
            fi
            ;;
        "numeric")
            if [[ "$input" =~ ^[0-9]+$ ]]; then
                return 0
            else
                echo "Error: Non-numeric input detected" >&2
                return 1
            fi
            ;;
    esac
    return 0
}

# Initialize default values for command line arguments with validation
if [[ $# -gt 0 ]]; then
    validate_input "$1" "command" || exit 1
fi
: "${1:=""}"

# Enhanced root check with secure elevation
secure_root_check() {
    # Skip root check if already root or in test mode
    if [ "$(id -u)" -eq 0 ] || [[ "${SKIP_ROOT_CHECK:-0}" == "1" ]] || [[ "${DRY_RUN:-0}" == "1" ]]; then
        return 0
    fi
    
    # Prevent infinite recursion
    if [[ "${ROOT_CHECK_ATTEMPTED:-0}" == "1" ]]; then
        echo "Error: Root check already attempted, avoiding infinite loop" >&2
        exit 1
    fi
    export ROOT_CHECK_ATTEMPTED=1
    
    if [ "$(id -u)" -ne 0 ]; then
        echo "This script must be run as root." >&2
        echo "Attempting secure root elevation..."
        
        # Validate su binary before use
        local su_binary=""
        for potential_su in "/system/bin/su" "/system/xbin/su" "/su/bin/su"; do
            if [[ -f "$potential_su" && -x "$potential_su" ]]; then
                # Additional security check - verify it's a legitimate su binary
                if file "$potential_su" 2>/dev/null | grep -q "executable"; then
                    su_binary="$potential_su"
                    break
                fi
            fi
        done
        
        if [[ -n "$su_binary" ]]; then
            # Secure execution with argument validation
            local safe_args=""
            for arg in "$@"; do
                validate_input "$arg" "command" || exit 1
                safe_args="$safe_args '$arg'"
            done
            exec "$su_binary" -c "$(printf '%q' "$0") $safe_args"
        else
            echo "Error: No valid su binary found" >&2
            if [[ "${TERMUX_ENV:-0}" == "1" ]]; then
                echo "Hint: In Termux, try installing 'tsu' package" >&2
            fi
            exit 1
        fi
    fi
}

# Call secure root check
secure_root_check "$@"

# Confirm root access
echo "Root access confirmed (UID: $(id -u))"

# Version and branding
VERSION="1.1-enhanced"
BRAND_NAME="Enhanced Superuser Terminal"

# Logging
LOG_DIR="/data/local/tmp/superuser_logs"
LOG_FILE="$LOG_DIR/superuser_install.log"
MAX_LOGS=12
mkdir -p "$LOG_DIR" 2>/dev/null || {
    echo "Warning: Could not create log directory $LOG_DIR" >&2
    LOG_DIR="/tmp/superuser_logs"
    LOG_FILE="$LOG_DIR/superuser_install.log"
    mkdir -p "$LOG_DIR" 2>/dev/null || {
        echo "Error: Could not create fallback log directory $LOG_DIR" >&2
        exit 1
    }
}

# Enhanced logging function with error handling
log() {
    local level="${1:-INFO}"
    shift || true
    local message="${*:-No message provided}"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown-time")
    
    # Ensure log directory exists
    if [ ! -d "$LOG_DIR" ]; then
        mkdir -p "$LOG_DIR" 2>/dev/null || {
            echo "Warning: Could not create log directory $LOG_DIR" >&2
            return 1
        }
    fi
    
    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE" 2>/dev/null || {
        echo "[$timestamp] [$level] $message"
        echo "Warning: Could not write to log file $LOG_FILE" >&2
    }
}

# Rotate logs if needed
if [ $(ls "$LOG_DIR"/*.log 2>/dev/null | wc -l) -ge $MAX_LOGS ]; then
    rm "$(ls -t "$LOG_DIR"/*.log | tail -1)"
fi

# Improved color array (declare -A for associative array)
declare -A COLORS=(
    [RED]='\033[0;31m'
    [GREEN]='\033[0;32m'
    [CYAN]='\033[0;36m'
    [YELLOW]='\033[1;33m'
    [BLUE]='\033[0;34m'
    [PURPLE]='\033[0;35m'
    [NC]='\033[0m'
)

# Performance-optimized dependency checker
check_dependencies() {
    echo -e "${COLORS[CYAN]}Checking system dependencies...${COLORS[NC]}"
    log "INFO" "Starting optimized dependency check"
    
    local missing_deps=()
    local required_commands=("stat" "chmod" "chown" "mkdir" "grep" "awk" "date")
    local optional_commands=("df" "uname" "cut" "head" "tail" "file" "timeout" "getenforce" "busybox" "adb" "magisk" "su" "id" "tsu")

    # Parallel dependency checking for better performance
    check_command_batch() {
        local commands=("$@")
        local results=()
        
        for cmd in "${commands[@]}"; do
            if command -v "$cmd" >/dev/null 2>&1; then
                results+=("FOUND:$cmd")
            else
                results+=("MISSING:$cmd")
            fi
        done
        
        printf '%s\n' "${results[@]}"
    }

    # Check required commands in parallel
    local required_results
    mapfile -t required_results < <(check_command_batch "${required_commands[@]}")
    
    for result in "${required_results[@]}"; do
        local status="${result%%:*}"
        local cmd="${result##*:}"
        
        if [[ "$status" == "MISSING" ]]; then
            missing_deps+=("$cmd")
            echo -e "${COLORS[RED]}‚úó${COLORS[NC]} Missing required command: $cmd"
        else
            echo -e "${COLORS[GREEN]}‚úì${COLORS[NC]} Found: $cmd"
        fi
    done
    
    # Check optional commands
    local optional_results
    mapfile -t optional_results < <(check_command_batch "${optional_commands[@]}")
    
    for result in "${optional_results[@]}"; do
        local status="${result%%:*}"
        local cmd="${result##*:}"
        
        if [[ "$status" == "FOUND" ]]; then
            echo -e "${COLORS[GREEN]}‚úì${COLORS[NC]} Found (optional): $cmd"
        else
            echo -e "${COLORS[YELLOW]}!${COLORS[NC]} Missing (optional): $cmd"
        fi
    done
    
    # Enhanced dependency resolution with caching
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo -e "${COLORS[YELLOW]}Attempting to resolve missing dependencies...${COLORS[NC]}"
        
        # Cache busybox detection
        local busybox_available=""
        if [[ -z "$busybox_available" ]]; then
            busybox_available=$(command -v busybox >/dev/null 2>&1 && echo "yes" || echo "no")
        fi
        
        if [[ "$busybox_available" == "yes" ]]; then
            echo -e "${COLORS[GREEN]}BusyBox detected - resolving dependencies...${COLORS[NC]}"
            
            # Batch process missing dependencies
            for dep in "${missing_deps[@]}"; do
                if busybox "$dep" --help >/dev/null 2>&1; then
                    if [[ -w "/system/bin" ]] 2>/dev/null; then
                        ln -sf "$(command -v busybox)" "/system/bin/$dep" 2>/dev/null || true
                        echo -e "${COLORS[GREEN]}‚úì${COLORS[NC]} Resolved: $dep -> busybox"
                    fi
                fi
            done
        else
            echo -e "${COLORS[RED]}Critical dependencies missing and no BusyBox available${COLORS[NC]}"
            log "ERROR" "Missing critical dependencies: ${missing_deps[*]}"
            echo -e "${COLORS[YELLOW]}Continuing with limited functionality...${COLORS[NC]}"
            return 1
        fi
    fi
    
    echo -e "${COLORS[GREEN]}Dependency check completed${COLORS[NC]}"
    log "INFO" "Dependency check completed successfully"
    return 0
}

# Enhanced system information with caching
check_system_info() {
    echo -e "${COLORS[CYAN]}System Information Check:${COLORS[NC]}"
    log "INFO" "Starting enhanced system information check"
    
    # Cache system properties for performance
    local -A system_cache=()
    
    populate_system_cache() {
        local build_prop_files=("/system/build.prop" "/vendor/build.prop" "/product/build.prop")
        
        for prop_file in "${build_prop_files[@]}"; do
            if [[ -f "$prop_file" ]]; then
                while IFS='=' read -r key value; do
                    [[ "$key" =~ ^ro\. ]] && system_cache["$key"]="$value"
                done < "$prop_file"
                break
            fi
        done
    }
    
    populate_system_cache
    
    # Enhanced Android version detection
    local android_version="${system_cache[ro.build.version.release]:-Unknown}"
    local api_level="${system_cache[ro.build.version.sdk]:-Unknown}"
    local device_model="${system_cache[ro.product.model]:-Unknown}"
    local device_brand="${system_cache[ro.product.brand]:-Unknown}"
    
    # Validate and display system information
    if [[ "$api_level" =~ ^[0-9]+$ ]]; then
        validate_input "$api_level" "numeric" || api_level="Unknown"
    fi
    
    echo -e "${COLORS[GREEN]}Device: $device_brand $device_model${COLORS[NC]}"
    echo -e "${COLORS[GREEN]}Android Version: $android_version (API $api_level)${COLORS[NC]}"
    log "INFO" "Device: $device_brand $device_model, Android: $android_version (API $api_level)"
    
    # Enhanced architecture detection with performance optimization
    local arch
    arch=$(uname -m 2>/dev/null || echo "unknown")
    local cpu_abi="${system_cache[ro.product.cpu.abi]:-}"
    local cpu_abi2="${system_cache[ro.product.cpu.abi2]:-}"
    
    echo -e "${COLORS[GREEN]}Architecture: $arch${COLORS[NC]}"
    [[ -n "$cpu_abi" ]] && echo -e "${COLORS[GREEN]}Primary ABI: $cpu_abi${COLORS[NC]}"
    [[ -n "$cpu_abi2" ]] && echo -e "${COLORS[GREEN]}Secondary ABI: $cpu_abi2${COLORS[NC]}"
    
    # Parallel system checks for better performance
    {
        # Memory information
        if [[ -f "/proc/meminfo" ]]; then
            local total_mem
            total_mem=$(awk '/MemTotal/ {print int($2/1024) " MB"}' /proc/meminfo 2>/dev/null || echo "Unknown")
            echo -e "${COLORS[GREEN]}Total Memory: $total_mem${COLORS[NC]}"
        fi
        
        # Storage information
        if command -v df >/dev/null 2>&1; then
            local available_space
            available_space=$(df /data 2>/dev/null | tail -1 | awk '{print int($4/1024) " MB"}' || echo "Unknown")
            echo -e "${COLORS[GREEN]}Available /data space: $available_space${COLORS[NC]}"
        fi
        
        # SELinux status
        if command -v getenforce >/dev/null 2>&1; then
            local selinux_status
            selinux_status=$(getenforce 2>/dev/null || echo "Unknown")
            echo -e "${COLORS[YELLOW]}SELinux Status: $selinux_status${COLORS[NC]}"
        fi
    } &
    
    wait
    
    log "INFO" "System information check completed"
}

# Enhanced device compatibility check
check_device_compatibility() {
    echo -e "${COLORS[CYAN]}Device Compatibility Check:${COLORS[NC]}"
    log "INFO" "Starting device compatibility check"
    
    local compatibility_score=0
    local total_checks=0
    
    # Check for root access indicators
    local root_indicators=(
        "/system/app/Superuser.apk"
        "/system/etc/init.d"
        "/system/bin/busybox"
        "/data/local/tmp"
    )
    
    for indicator in "${root_indicators[@]}"; do
        ((total_checks++))
        if [ -e "$indicator" ]; then
            echo -e "${COLORS[GREEN]}‚úì${COLORS[NC]} Found: $indicator"
            ((compatibility_score++))
        else
            echo -e "${COLORS[RED]}‚úó${COLORS[NC]} Missing: $indicator"
        fi
    done
    
    # Calculate compatibility percentage
    local compatibility_percent=$((compatibility_score * 100 / total_checks))
    echo -e "${COLORS[BLUE]}Compatibility Score: $compatibility_percent%${COLORS[NC]}"
    log "INFO" "Device compatibility score: $compatibility_percent%"
    
    if [ $compatibility_percent -lt 50 ]; then
        echo -e "${COLORS[RED]}Warning: Low compatibility detected. Proceed with caution.${COLORS[NC]}"
        log "WARN" "Low compatibility detected"
    fi
}

# List of su binary locations
SU_PATHS=(
    "/system/bin/su" "/system/xbin/su" "/sbin/su" "/su/bin/su" "/su/xbin/su" "/system/sbin/su" "/magisk/.core/bin/su" "/debug_ramdisk/su" "/sbin/bin/su" "/system/su" "/system/xbin/daemonsu" "/system/xbin/busybox" "/su" "/xbin/su" "/bin/su" "/0/su"
)

# Setup root superuser directories and permissions
setup_root_superuser() {
    local root_dirs=(
        "/data/superuser"
        "/data/superuser/bin"
        "/data/superuser/etc"
        "/data/superuser/lib"
        "/data/superuser/tmp"
    )
    for dir in "${root_dirs[@]}"; do
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir"
            echo -e "${COLORS[YELLOW]}Created $dir${COLORS[NC]}"
        fi
        chmod 700 "$dir"
        chown root:root "$dir"
    done
    cat > /data/superuser/etc/profile << EOF
export PATH="/data/superuser/bin:$PATH"
export SUPERUSER_HOME="/data/superuser"
PS1='root@superuser:\w# '
EOF
}

# Enhanced su permissions fix with safety checks
fix_su_permissions() {
    echo -e "${COLORS[CYAN]}Fixing su binary permissions...${COLORS[NC]}"
    log "INFO" "Starting su permissions fix"
    
    local fixed_count=0
    local total_found=0
    local failed_paths=()
    
    for su_path in "${SU_PATHS[@]}"; do
        # Validate path before processing
        validate_input "$su_path" "path" || continue
        
        if [[ -f "$su_path" ]]; then
            ((total_found++))
            
            # Enhanced safety checks
            local file_type=""
            if command -v file >/dev/null 2>&1; then
                file_type=$(file "$su_path" 2>/dev/null || echo "")
            fi
            
            # Verify it's an executable and not a script
            if [[ "$file_type" =~ (executable|ELF) ]] || [[ -x "$su_path" ]]; then
                # Create timestamped backup
                local backup_dir="/data/superuser/backup"
                mkdir -p "$backup_dir" 2>/dev/null || {
                    log "WARN" "Could not create backup directory"
                    continue
                }
                
                local backup_name="$backup_dir/$(basename "$su_path").backup.$(date +%s)"
                if cp "$su_path" "$backup_name" 2>/dev/null; then
                    log "INFO" "Created backup: $backup_name"
                else
                    log "WARN" "Could not create backup for $su_path"
                fi
                
                # Apply permissions with error handling
                local success=true
                chmod 6755 "$su_path" 2>/dev/null || {
                    echo -e "${COLORS[RED]}Failed to set permissions for $su_path${COLORS[NC]}"
                    log "ERROR" "chmod failed for $su_path"
                    failed_paths+=("$su_path")
                    success=false
                }
                
                chown root:root "$su_path" 2>/dev/null || {
                    echo -e "${COLORS[RED]}Failed to set ownership for $su_path${COLORS[NC]}"
                    log "ERROR" "chown failed for $su_path"
                    if [[ "$success" == "true" ]]; then
                        failed_paths+=("$su_path")
                        success=false
                    fi
                }
                
                if [[ "$success" == "true" ]]; then
                    echo -e "${COLORS[GREEN]}Fixed permissions for $su_path${COLORS[NC]}"
                    log "INFO" "Fixed permissions for $su_path"
                    ((fixed_count++))
                fi
            else
                echo -e "${COLORS[YELLOW]}Skipping $su_path (not a valid executable)${COLORS[NC]}"
                log "WARN" "Skipped $su_path - not a valid executable"
            fi
        fi
    done
    
    echo -e "${COLORS[BLUE]}Summary: Fixed $fixed_count out of $total_found su binaries${COLORS[NC]}"
    log "INFO" "Su permissions fix completed: $fixed_count/$total_found"
    
    # Report failures and suggest recovery
    if [[ ${#failed_paths[@]} -gt 0 ]]; then
        echo -e "${COLORS[YELLOW]}Failed to fix permissions for:${COLORS[NC]}"
        for path in "${failed_paths[@]}"; do
            echo -e "${COLORS[RED]}  - $path${COLORS[NC]}"
        done
        echo -e "${COLORS[CYAN]}Recovery suggestions:${COLORS[NC]}"
        echo "  - Check if filesystem is mounted read-only"
        echo "  - Verify SELinux policy allows modifications"
        echo "  - Ensure sufficient disk space"
        return 1
    fi
    
    return 0
}

# Enhanced backup function
backup_critical_files() {
    echo -e "${COLORS[CYAN]}Creating backup of critical files...${COLORS[NC]}"
    local backup_dir="/data/superuser/backup/$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"
    
    for su_path in "${SU_PATHS[@]}"; do
        if [ -f "$su_path" ]; then
            cp "$su_path" "$backup_dir/" 2>/dev/null && \
            echo -e "${COLORS[GREEN]}Backed up: $su_path${COLORS[NC]}" || \
            echo -e "${COLORS[RED]}Failed to backup: $su_path${COLORS[NC]}"
        fi
    done
    
    echo -e "${COLORS[BLUE]}Backup location: $backup_dir${COLORS[NC]}"
    log "INFO" "Backup created at: $backup_dir"
}

# Improved accessibility check: also test execution
check_accessibility() {
    echo -e "${COLORS[CYAN]}\nAccessibility Check Summary:${COLORS[NC]}"
    log "INFO" "Starting accessibility check"
    local all_ok=1
    local found_count=0
    local working_count=0
    local issues=()
    
    for su_path in "${SU_PATHS[@]}"; do
        validate_input "$su_path" "path" || continue
        
        if [[ -f "$su_path" ]]; then
            ((found_count++))
            local perms=$(stat -c %a "$su_path" 2>/dev/null || echo "000")
            local owner=$(stat -c %U "$su_path" 2>/dev/null || echo "unknown")
            local group=$(stat -c %G "$su_path" 2>/dev/null || echo "unknown")
            
            if [[ "$perms" == "6755" && "$owner" == "root" && "$group" == "root" ]]; then
                # Enhanced executable test with timeout and error capture
                local test_result=""
                if command -v timeout >/dev/null 2>&1; then
                    test_result=$(timeout 5 "$su_path" --version 2>&1 || timeout 5 "$su_path" -c "id" 2>&1 || echo "failed")
                else
                    # Fallback without timeout
                    test_result=$("$su_path" --version 2>&1 || "$su_path" -c "id" 2>&1 || echo "failed")
                fi
                
                if [[ "$test_result" != "failed" && ! "$test_result" =~ (not found|denied|invalid) ]]; then
                    echo -e "${COLORS[GREEN]}OK${COLORS[NC]} $su_path (6755 root:root, executable)"
                    ((working_count++))
                    log "INFO" "Su binary working: $su_path"
                else
                    echo -e "${COLORS[YELLOW]}WARN${COLORS[NC]} $su_path (permissions OK, execution failed: ${test_result:0:50})"
                    issues+=("$su_path: execution failed")
                    all_ok=0
                    log "WARN" "Su binary not executable: $su_path - $test_result"
                fi
            else
                echo -e "${COLORS[RED]}BAD${COLORS[NC]} $su_path (perms: $perms, owner: $owner:$group)"
                issues+=("$su_path: incorrect permissions/ownership")
                all_ok=0
                log "ERROR" "Su binary bad permissions: $su_path"
            fi
        fi
    done
    
    echo -e "${COLORS[BLUE]}Summary: Found $found_count su binaries, $working_count working${COLORS[NC]}"
    
    # Check root superuser dir
    if [ -d "/data/superuser" ]; then
        perms=$(stat -c %a /data/superuser)
        owner=$(stat -c %U /data/superuser)
        group=$(stat -c %G /data/superuser)
        if [ "$perms" = "700" ] && [ "$owner" = "root" ] && [ "$group" = "root" ]; then
            echo -e "${COLORS[GREEN]}OK${COLORS[NC]} /data/superuser (700 root:root)"
        else
            echo -e "${COLORS[RED]}BAD${COLORS[NC]} /data/superuser (perms: $perms, owner: $owner:$group)"
            all_ok=0
        fi
    else
        echo -e "${COLORS[RED]}MISSING${COLORS[NC]} /data/superuser"
        all_ok=0
    fi
    
    # Enhanced diagnostics for issues
    if [[ ${#issues[@]} -gt 0 ]]; then
        echo -e "${COLORS[YELLOW]}Detected Issues:${COLORS[NC]}"
        for issue in "${issues[@]}"; do
            echo -e "${COLORS[RED]}  - $issue${COLORS[NC]}"
        done
        echo -e "${COLORS[CYAN]}Troubleshooting suggestions:${COLORS[NC]}"
        echo "  - Run 'setenforce 0' to temporarily disable SELinux"
        echo "  - Check mount options: 'mount | grep system'"
        echo "  - Verify root access: 'id'"
        echo "  - Check for Magisk/SuperSU conflicts"
    fi
    
    if [[ $all_ok -eq 1 ]]; then
        echo -e "${COLORS[GREEN]}All checks passed!${COLORS[NC]}"
        log "INFO" "All accessibility checks passed"
    else
        echo -e "${COLORS[RED]}Some issues detected. Please review above.${COLORS[NC]}"
        log "ERROR" "Accessibility check failed"
    fi
    
    return $all_ok
}

# Auto-install adb if missing
install_adb_if_missing() {
    if ! command -v adb >/dev/null 2>&1; then
        echo -e "${COLORS[YELLOW]}adb not found. Attempting to install Android Platform Tools...${COLORS[NC]}"
        if command -v apt-get >/dev/null 2>&1; then
            apt-get update && apt-get install -y android-tools-adb && echo -e "${COLORS[GREEN]}adb installed.${COLORS[NC]}"
        elif command -v yum >/dev/null 2>&1; then
            yum install -y android-tools && echo -e "${COLORS[GREEN]}adb installed.${COLORS[NC]}"
        else
            echo -e "${COLORS[RED]}Could not auto-install adb. Please install it manually.${COLORS[NC]}"
        fi
    fi
}

# Android command terminal function
android_cmd_terminal() {
    install_adb_if_missing
    echo -e "${COLORS[CYAN]}Launching Android command terminal...${COLORS[NC]}"
    
    if ! command -v adb >/dev/null 2>&1; then
        echo -e "${COLORS[RED]}adb not found. Please install Android Platform Tools.${COLORS[NC]}"
        return 1
    fi
    
    # Start adb server
    if adb start-server >/dev/null 2>&1; then
        echo -e "${COLORS[GREEN]}adb server started.${COLORS[NC]}"
    else
        echo -e "${COLORS[YELLOW]}adb server already running or failed to start.${COLORS[NC]}"
    fi
    
    # Check device connection
    local device=$(adb get-state 2>/dev/null || echo "unknown")
    if [[ "$device" == "device" ]]; then
        echo -e "${COLORS[GREEN]}Connected to device: $device${COLORS[NC]}"
    else
        echo -e "${COLORS[RED]}No device connected or authorized.${COLORS[NC]}"
        echo -e "${COLORS[YELLOW]}Please connect your device and enable USB debugging.${COLORS[NC]}"
        return 1
    fi
    
    # Launch adb shell
    echo -e "${COLORS[CYAN]}Opening adb shell...${COLORS[NC]}"
    echo -e "${COLORS[CYAN]}You are now in the adb shell. Type 'exit' to return.${COLORS[NC]}"
    
    adb shell || {
        echo -e "${COLORS[RED]}Failed to open adb shell. Is your device connected and authorized?${COLORS[NC]}"
        return 1
    }
    
    echo -e "${COLORS[GREEN]}adb shell session ended.${COLORS[NC]}"
}

# Android user account and id info
android_user_info() {
    install_adb_if_missing
    echo -e "${COLORS[CYAN]}Android User Account & ID Info:${COLORS[NC]}"
    if ! command -v adb >/dev/null 2>&1; then
        echo -e "${COLORS[RED]}adb not found. Please install Android Platform Tools.${COLORS[NC]}"
        return 1
    fi
    adb start-server >/dev/null 2>&1
    adb shell 'pm list users; id; whoami; getprop persist.sys.device_name; getprop ro.product.model; getprop ro.serialno' 2>/dev/null || {
        echo -e "${COLORS[RED]}Failed to retrieve user info. Is your device connected and authorized?${COLORS[NC]}"
        return 1
    }
}

# Auto-configure sudo/root superuser if possible
auto_configure_sudo() {
    echo -e "${COLORS[CYAN]}Checking sudo/root superuser configuration...${COLORS[NC]}"
    # Check if sudo is installed
    if ! command -v sudo >/dev/null 2>&1; then
        echo -e "${COLORS[YELLOW]}sudo not found. Attempting to install...${COLORS[NC]}"
        if command -v apt-get >/dev/null 2>&1; then
            apt-get update && apt-get install -y sudo && echo -e "${COLORS[GREEN]}sudo installed.${COLORS[NC]}"
        elif command -v yum >/dev/null 2>&1; then
            yum install -y sudo && echo -e "${COLORS[GREEN]}sudo installed.${COLORS[NC]}"
        else
            echo -e "${COLORS[RED]}Could not auto-install sudo. Please install it manually.${COLORS[NC]}"
        fi
    else
        echo -e "${COLORS[GREEN]}sudo is present.${COLORS[NC]}"
    fi
    # Ensure current user is in sudoers if not root
    if [ "$(id -u)" -ne 0 ]; then
        user=$(whoami)
        if sudo -l -U "$user" | grep -q '(ALL) ALL'; then
            echo -e "${COLORS[GREEN]}$user already has sudo privileges.${COLORS[NC]}"
        else
            echo -e "${COLORS[YELLOW]}$user does not have sudo privileges. Attempting to add...${COLORS[NC]}"
            echo "$user ALL=(ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/$user >/dev/null && \
            echo -e "${COLORS[GREEN]}$user added to sudoers (NOPASSWD).${COLORS[NC]}"
        fi
    fi
}

# Test sudo/root superuser access
check_sudo_root_access() {
    echo -e "${COLORS[CYAN]}Testing sudo/root superuser access...${COLORS[NC]}"
    if [ "$(id -u)" -eq 0 ]; then
        echo -e "${COLORS[GREEN]}Already running as root.${COLORS[NC]}"
    else
        if sudo -n true 2>/dev/null; then
            echo -e "${COLORS[GREEN]}Sudo access confirmed for $(whoami).${COLORS[NC]}"
        else
            echo -e "${COLORS[RED]}Sudo access failed for $(whoami).${COLORS[NC]}"
        fi
    fi
}

# Detect Termux environment
detect_termux() {
    if [[ -d "/data/data/com.termux" ]] || [[ -n "${TERMUX_VERSION:-}" ]] || [[ "${PREFIX:-}" == *"com.termux"* ]]; then
        export TERMUX_ENV=1
        export PREFIX="${PREFIX:-/data/data/com.termux/files/usr}"
        export TERMUX_HOME="${TERMUX_HOME:-/data/data/com.termux/files/home}"
        
        log "INFO" "Termux environment detected"
        echo -e "${COLORS[YELLOW]}üîß Termux Environment Detected${COLORS[NC]}"
        return 0
    fi
    return 1
}

# Termux integration features
termux_integration() {
    if [[ "${TERMUX_ENV}" == "1" ]]; then
        log "INFO" "Enabling Termux integration features"
        
        # Termux API integration
        if command -v termux-notification >/dev/null 2>&1; then
            termux-notification --title "Superuser Terminal" --content "Root access session started" 2>/dev/null || true
        fi
        
        # Storage access check
        if [[ ! -d "/storage" && ! -d "$HOME/storage" ]]; then
            log "WARN" "Storage access not configured. Run: termux-setup-storage"
            echo -e "${COLORS[YELLOW]}‚ö†Ô∏è Storage access not configured. Run: termux-setup-storage${COLORS[NC]}"
        fi
        
        # Set Termux-specific environment
        export TERMUX_APP_PACKAGE="com.termux"
        export SHELL="${PREFIX}/bin/bash"
        
        # Create Termux-specific directories
        mkdir -p "$TERMUX_HOME/.config" "$TERMUX_HOME/.local/share" 2>/dev/null || true
    fi
}

# Termux interactive mode
termux_interactive_mode() {
    while true; do
        clear
        echo -e "${COLORS[PURPLE]}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${COLORS[NC]}"
        echo -e "${COLORS[PURPLE]}‚ïë     üîê ENHANCED SUPERUSER TERMINAL - TERMUX üîê       ‚ïë${COLORS[NC]}"
        echo -e "${COLORS[PURPLE]}‚ïë                   v$VERSION                           ‚ïë${COLORS[NC]}"
        echo -e "${COLORS[PURPLE]}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${COLORS[NC]}"
        echo ""
        echo -e "${COLORS[CYAN]}üì± ANDROID OPERATIONS:${COLORS[NC]}"
        echo "1. üîç Full system check"
        echo "2. üîß Fix su permissions"
        echo "3. üì± Android terminal"
        echo "4. üìä Device information"
        echo "5. üíæ Create backup"
        echo ""
        echo -e "${COLORS[CYAN]}üõ†Ô∏è TERMUX TOOLS:${COLORS[NC]}"
        echo "6. üñ•Ô∏è Launch GUI (VNC)"
        echo "7. üîß Termux tools menu"
        echo "8. üìù View logs"
        echo "9. ‚öôÔ∏è System configuration"
        echo ""
        echo "0. ‚ùå Exit"
        echo ""
        echo -n "Select option [0-9]: "
        read -r choice
        
        case $choice in
            1)
                echo -e "${COLORS[GREEN]}Running full system check...${COLORS[NC]}"
                check_system_info || true
                check_device_compatibility || true
                setup_root_superuser || true
                fix_su_permissions || true
                check_accessibility || true
                ;;
            2)
                echo -e "${COLORS[GREEN]}Fixing permissions...${COLORS[NC]}"
                fix_su_permissions || true
                check_accessibility || true
                ;;
            3)
                android_cmd_terminal || true
                ;;
            4)
                android_user_info || true
                if command -v termux-telephony-deviceinfo >/dev/null 2>&1; then
                    echo -e "${COLORS[CYAN]}Termux Device Info:${COLORS[NC]}"
                    termux-telephony-deviceinfo 2>/dev/null || echo "Device info not available"
                fi
                ;;
            5)
                backup_critical_files || true
                ;;
            6)
                if command -v vncserver >/dev/null 2>&1; then
                    echo -e "${COLORS[GREEN]}üñ•Ô∏è Starting VNC server...${COLORS[NC]}"
                    vncserver :1 -geometry 1280x720 2>/dev/null || echo "VNC start failed"
                    echo "Connect VNC client to localhost:5901"
                else
                    echo -e "${COLORS[RED]}VNC server not installed${COLORS[NC]}"
                    echo "Install with: pkg install tigervnc"
                fi
                ;;
            7)
                termux_tools_menu || echo "Tools menu not available"
                ;;
            8)
                echo -e "${COLORS[CYAN]}Recent log entries:${COLORS[NC]}"
                tail -20 "$LOG_FILE" 2>/dev/null || echo "No logs found"
                ;;
            9)
                termux_system_config || echo "System config not available"
                ;;
            0)
                echo -e "${COLORS[GREEN]}üëã Goodbye from Termux!${COLORS[NC]}"
                if command -v termux-notification >/dev/null 2>&1; then
                    termux-notification --title "Superuser Terminal" --content "Session ended" 2>/dev/null || true
                fi
                break
                ;;
            *)
                echo -e "${COLORS[RED]}‚ùå Invalid option. Please try again.${COLORS[NC]}"
                sleep 1
                ;;
        esac
        
        if [[ $choice != 0 ]]; then
            echo ""
            read -p "Press Enter to continue..."
        fi
    done
}

# Termux tools menu
termux_tools_menu() {
    echo -e "${COLORS[CYAN]}üîß Termux Tools Menu:${COLORS[NC]}"
    echo "1. Package manager (pkg)"
    echo "2. Setup storage access"
    echo "3. Install development tools"
    echo "4. Network tools"
    echo "5. Back to main menu"
    echo -n "Select option [1-5]: "
    read -r tool_choice
    
    case $tool_choice in
        1)
            echo -e "${COLORS[GREEN]}Opening package manager...${COLORS[NC]}"
            pkg list-installed | head -20
            echo "Use 'pkg install <package>' to install new packages"
            ;;
        2)
            echo -e "${COLORS[GREEN]}Setting up storage access...${COLORS[NC]}"
            termux-setup-storage || echo "termux-setup-storage not available"
            ;;
        3)
            echo -e "${COLORS[GREEN]}Installing development tools...${COLORS[NC]}"
            pkg install -y git make clang python nodejs || echo "Installation failed"
            ;;
        4)
            echo -e "${COLORS[GREEN]}Network tools available:${COLORS[NC]}"
            echo "- curl, wget: Download tools"
            echo "- openssh: SSH client/server"
            echo "- nmap: Network scanner"
            ;;
        5)
            return 0
            ;;
        *)
            echo -e "${COLORS[RED]}Invalid option${COLORS[NC]}"
            ;;
    esac
}

# Termux system configuration
termux_system_config() {
    echo -e "${COLORS[CYAN]}üìã Termux System Configuration:${COLORS[NC]}"
    echo "Termux prefix: ${PREFIX:-Not set}"
    echo "Termux home: ${TERMUX_HOME:-Not set}"
    echo "Storage access: $(test -d /storage && echo "‚úÖ Available" || echo "‚ùå Run termux-setup-storage")"
    echo "Root access: $(test "$(id -u)" -eq 0 && echo "‚úÖ Active" || echo "‚ùå Not root")"
    echo "TSU available: $(command -v tsu >/dev/null && echo "‚úÖ Yes" || echo "‚ùå No")"
    echo "Python: $(python3 --version 2>/dev/null || echo "Not installed")"
    echo "Git: $(git --version 2>/dev/null || echo "Not installed")"
    echo "Node.js: $(node --version 2>/dev/null || echo "Not installed")"
}

# Test result function for CI compatibility
test_result() {
    local test_name="$1"
    local result="$2"
    
    if [[ "$result" -eq 0 ]]; then
        echo -e "${COLORS[GREEN]}‚úì ${test_name}${COLORS[NC]}"
        log "INFO" "$test_name passed"
        return 0
    else
        echo -e "${COLORS[RED]}‚úó ${test_name}${COLORS[NC]}"
        log "ERROR" "$test_name failed with exit code $result"
        return 1
    fi
}

# Create directories function for CI compatibility
create_directories() {
    echo -e "${COLORS[CYAN]}Creating required directories...${COLORS[NC]}"
    
    # Create GitHub workflows directory
    mkdir -p .github/workflows logs backups || {
        echo -e "${COLORS[RED]}Error: Failed to create directories${COLORS[NC]}" >&2
        return 1
    }
    
    # Move CI test file if it exists in wrong location
    if [[ -f "superuser.test" ]]; then
        echo -e "${COLORS[YELLOW]}Moving CI test file to correct location...${COLORS[NC]}"
        mv superuser.test .github/workflows/ci.yml || {
            echo -e "${COLORS[RED]}Error: Failed to move CI file${COLORS[NC]}" >&2
            return 1
        }
    fi
    
    # Create .gitignore if missing
    if [[ ! -f ".gitignore" ]]; then
        echo -e "${COLORS[CYAN]}Creating .gitignore...${COLORS[NC]}"
        cat > .gitignore << 'EOF'
# Logs
logs/
*.log

# Backups
backups/
*.backup

# Temporary files
*.tmp
*.swp
*.bak

# IDE files
.vscode/
.idea/

# OS files
.DS_Store
Thumbs.db

# Python cache
__pycache__/
*.pyc
*.pyo

# Node modules
node_modules/

# Build artifacts
*.o
*.so
*.exe
*.out
EOF
    fi
    
    echo -e "${COLORS[GREEN]}‚úì All directories created successfully${COLORS[NC]}"
    return 0
}

# Enhanced network diagnostics
check_network_connectivity() {
    echo -e "${COLORS[CYAN]}Network Connectivity Check:${COLORS[NC]}"
    log "INFO" "Starting network connectivity check"
    
    local connectivity_score=0
    local total_tests=0
    
    # Test DNS resolution
    ((total_tests++))
    if command -v nslookup >/dev/null 2>&1; then
        if nslookup google.com >/dev/null 2>&1; then
            echo -e "${COLORS[GREEN]}‚úì${COLORS[NC]} DNS resolution working"
            ((connectivity_score++))
        else
            echo -e "${COLORS[RED]}‚úó${COLORS[NC]} DNS resolution failed"
        fi
    else
        echo -e "${COLORS[YELLOW]}!${COLORS[NC]} nslookup not available"
    fi
    
    # Test network interfaces
    ((total_tests++))
    if command -v ip >/dev/null 2>&1; then
        local active_interfaces=$(ip link show up | grep -c "state UP" || echo "0")
        if [[ "$active_interfaces" -gt 0 ]]; then
            echo -e "${COLORS[GREEN]}‚úì${COLORS[NC]} Network interfaces active: $active_interfaces"
            ((connectivity_score++))
        else
            echo -e "${COLORS[RED]}‚úó${COLORS[NC]} No active network interfaces"
        fi
    else
        echo -e "${COLORS[YELLOW]}!${COLORS[NC]} ip command not available"
    fi
    
    # Calculate connectivity score
    local connectivity_percent=$((connectivity_score * 100 / total_tests))
    echo -e "${COLORS[BLUE]}Network Score: $connectivity_percent%${COLORS[NC]}"
    log "INFO" "Network connectivity score: $connectivity_percent%"
}

# Enhanced security audit
security_audit() {
    echo -e "${COLORS[CYAN]}Security Audit:${COLORS[NC]}"
    log "INFO" "Starting security audit"
    
    local security_issues=0
    
    # Check for world-writable files in sensitive locations
    local sensitive_dirs=("/system" "/data/local/tmp" "/data/superuser")
    for dir in "${sensitive_dirs[@]}"; do
        if [[ -d "$dir" ]]; then
            local writable_files=$(find "$dir" -type f -perm -002 2>/dev/null | wc -l || echo "0")
            if [[ "$writable_files" -gt 0 ]]; then
                echo -e "${COLORS[YELLOW]}‚ö†${COLORS[NC]} Found $writable_files world-writable files in $dir"
                ((security_issues++))
            else
                echo -e "${COLORS[GREEN]}‚úì${COLORS[NC]} No world-writable files in $dir"
            fi
        fi
    done
    
    # Check su binary security
    for su_path in "${SU_PATHS[@]}"; do
        if [[ -f "$su_path" ]]; then
            local perms=$(stat -c %a "$su_path" 2>/dev/null || echo "000")
            if [[ "$perms" == "6755" ]]; then
                echo -e "${COLORS[GREEN]}‚úì${COLORS[NC]} $su_path has secure permissions"
            else
                echo -e "${COLORS[YELLOW]}‚ö†${COLORS[NC]} $su_path has permissions: $perms"
                ((security_issues++))
            fi
        fi
    done
    
    # Check for suspicious processes
    if command -v ps >/dev/null 2>&1; then
        local suspicious_procs=$(ps aux | grep -E "(adbd|debuggerd)" | grep -v grep | wc -l || echo "0")
        if [[ "$suspicious_procs" -gt 0 ]]; then
            echo -e "${COLORS[YELLOW]}‚ö†${COLORS[NC]} Found $suspicious_procs potentially suspicious processes"
        else
            echo -e "${COLORS[GREEN]}‚úì${COLORS[NC]} No suspicious processes detected"
        fi
    fi
    
    echo -e "${COLORS[BLUE]}Security Issues Found: $security_issues${COLORS[NC]}"
    log "INFO" "Security audit completed with $security_issues issues"
    
    return $security_issues
}

# System optimization suggestions
suggest_optimizations() {
    echo -e "${COLORS[CYAN]}System Optimization Suggestions:${COLORS[NC]}"
    log "INFO" "Generating optimization suggestions"
    
    # Memory optimization
    if [[ -f "/proc/meminfo" ]]; then
        local free_mem=$(awk '/MemAvailable/ {print $2}' /proc/meminfo 2>/dev/null || echo "0")
        local total_mem=$(awk '/MemTotal/ {print $2}' /proc/meminfo 2>/dev/null || echo "1")
        local mem_usage_percent=$((100 - (free_mem * 100 / total_mem)))
        
        if [[ "$mem_usage_percent" -gt 80 ]]; then
            echo -e "${COLORS[YELLOW]}üí°${COLORS[NC]} High memory usage ($mem_usage_percent%) - consider closing unused apps"
        else
            echo -e "${COLORS[GREEN]}‚úì${COLORS[NC]} Memory usage is optimal ($mem_usage_percent%)"
        fi
    fi
    
    # Storage optimization
    if command -v df >/dev/null 2>&1; then
        local data_usage=$(df /data 2>/dev/null | tail -1 | awk '{print $5}' | sed 's/%//' || echo "0")
        if [[ "$data_usage" -gt 90 ]]; then
            echo -e "${COLORS[YELLOW]}üí°${COLORS[NC]} High storage usage ($data_usage%) - consider cleaning cache"
        else
            echo -e "${COLORS[GREEN]}‚úì${COLORS[NC]} Storage usage is acceptable ($data_usage%)"
        fi
    fi
    
    # Performance suggestions
    if [[ -f "/proc/loadavg" ]]; then
        local load_avg=$(cut -d' ' -f1 /proc/loadavg 2>/dev/null || echo "0")
        if (( $(echo "$load_avg > 2.0" | bc -l 2>/dev/null || echo 0) )); then
            echo -e "${COLORS[YELLOW]}üí°${COLORS[NC]} High system load ($load_avg) - consider restarting device"
        else
            echo -e "${COLORS[GREEN]}‚úì${COLORS[NC]} System load is normal ($load_avg)"
        fi
    fi
    
    log "INFO" "Optimization suggestions completed"
}

# New benchmark function for performance testing
benchmark_system_performance() {
    echo -e "${COLORS[CYAN]}System Performance Benchmark:${COLORS[NC]}"
    
    local start_time
    start_time=$(date +%s.%N 2>/dev/null || date +%s)
    
    # CPU performance test
    echo "Testing CPU performance..."
    local time_result
    time_result=$(time (for i in {1..1000}; do echo "$i" >/dev/null; done) 2>&1 | grep real || echo "N/A")
    echo "CPU test: $time_result"
    
    # Memory performance test
    echo "Testing memory performance..."
    if command -v free >/dev/null 2>&1; then
        free -h
    else
        echo "Memory info not available"
    fi
    
    # Disk I/O performance test
    echo "Testing disk I/O performance..."
    if [[ -w "/data" ]]; then
        local test_file="/data/superuser_benchmark_test"
        dd if=/dev/zero of="$test_file" bs=1M count=10 2>&1 | grep -E "(copied|MB/s)" || echo "I/O test failed"
        rm -f "$test_file" 2>/dev/null
    else
        echo "Disk I/O test skipped (no write access)"
    fi
    
    local end_time
    end_time=$(date +%s.%N 2>/dev/null || date +%s)
    local benchmark_time
    benchmark_time=$(echo "$end_time - $start_time" | bc -l 2>/dev/null || echo "N/A")
    
    echo -e "${COLORS[GREEN]}Benchmark completed in ${benchmark_time} seconds${COLORS[NC]}"
    log "PERF" "System benchmark completed in ${benchmark_time} seconds"
}

# GUI mode detection and support
if [[ "${GUI_MODE:-}" == "1" ]]; then
    # Disable colored output for GUI consumption
    declare -A COLORS=(
        [RED]=''
        [GREEN]=''
        [CYAN]=''
        [YELLOW]=''
        [BLUE]=''
        [PURPLE]=''
        [NC]=''
    )
    
    # Enhanced logging for GUI
    log() {
        local level="${1:-INFO}"
        shift || true
        local message="${*:-No message provided}"
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown-time")
        
        # GUI-friendly output format
        echo "GUI_LOG:[$timestamp] [$level] $message"
        
        # Also log to file
        if [[ -d "$LOG_DIR" ]]; then
            echo "[$timestamp] [$level] $message" >> "$LOG_FILE" 2>/dev/null || true
        fi
    }
fi

# GUI command handler
handle_gui_command() {
    local command="$1"
    
    case "$command" in
        "gui-status")
            echo "GUI_STATUS:root=$(id -u)"
            echo "GUI_STATUS:version=$VERSION"
            echo "GUI_STATUS:timestamp=$(date)"
            ;;
        "gui-dependencies")
            check_dependencies 2>&1 | sed 's/^/GUI_DEP:/'
            ;;
        "gui-system-info")
            check_system_info 2>&1 | sed 's/^/GUI_SYSINFO:/'
            ;;
        *)
            # Regular command handling
            main "$command"
            ;;
    esac
}

# Check if being called from GUI
if [[ "${1:-}" == gui-* ]]; then
    export GUI_MODE=1
    handle_gui_command "$1"
    exit 0
fi

# Enhanced main function with new features
main() {
    local start_time
    start_time=$(date +%s)
    
    # Detect Termux environment first
    detect_termux || true
    
    echo -e "${COLORS[CYAN]}$BRAND_NAME v$VERSION${COLORS[NC]}"
    if [[ "${TERMUX_ENV:-0}" == "1" ]]; then
        echo -e "${COLORS[YELLOW]}üîß Termux Environment Detected${COLORS[NC]}"
    fi
    
    log "INFO" "Starting Enhanced Superuser Terminal v$VERSION"
    
    # Enable Termux integration if detected
    if [[ "${TERMUX_ENV:-0}" == "1" ]]; then
        termux_integration || {
            log "WARN" "Termux integration had issues"
            echo -e "${COLORS[YELLOW]}Warning: Termux integration incomplete${COLORS[NC]}"
        }
    fi
    
    # Pre-flight system validation
    if [[ "${DRY_RUN:-0}" != "1" ]]; then
        echo -e "${COLORS[CYAN]}Performing pre-flight checks...${COLORS[NC]}"
        
        # Check available disk space
        local available_kb
        available_kb=$(df /data 2>/dev/null | tail -1 | awk '{print $4}' || echo "0")
        if [[ "$available_kb" -lt 51200 ]] && [[ "$available_kb" != "0" ]]; then
            echo -e "${COLORS[YELLOW]}Warning: Low disk space (${available_kb}KB available)${COLORS[NC]}"
            log "WARN" "Low disk space warning: ${available_kb}KB"
        fi
        
        # Check system load
        if [[ -f "/proc/loadavg" ]]; then
            local load_avg
            load_avg=$(cut -d' ' -f1 /proc/loadavg 2>/dev/null || echo "0")
            if (( $(echo "$load_avg > 2.0" | bc -l 2>/dev/null || echo 0) )); then
                echo -e "${COLORS[YELLOW]}Warning: High system load ($load_avg)${COLORS[NC]}"
                log "WARN" "High system load: $load_avg"
            fi
        fi
    fi
    
    # Enhanced dependency checking with performance metrics
    local dep_start
    dep_start=$(date +%s)
    check_dependencies || {
        echo -e "${COLORS[YELLOW]}Continuing with limited functionality...${COLORS[NC]}"
        log "WARN" "Dependency check failed - limited functionality"
    }
    local dep_end
    dep_end=$(date +%s)
    log "PERF" "Dependency check took $((dep_end - dep_start)) seconds"
    
    # Command execution with enhanced error handling
    local command="${1:-check}"
    local cmd_start
    cmd_start=$(date +%s)
    
    case "$command" in
        "interactive"|"-i")
            if [[ "${TERMUX_ENV:-0}" == "1" ]]; then
                termux_interactive_mode
            else
                interactive_mode
            fi
            ;;
        "check")
            echo -e "${COLORS[GREEN]}Running comprehensive system check...${COLORS[NC]}"
            {
                check_system_info && test_result "System Info Check" $? &
                check_device_compatibility && test_result "Device Compatibility" $? &
                wait
            }
            echo -e "${COLORS[GREEN]}System check completed.${COLORS[NC]}"
            ;;
        "setup")
            echo -e "${COLORS[GREEN]}Running enhanced setup...${COLORS[NC]}"
            create_directories && test_result "Directory Creation" $?
            setup_root_superuser && test_result "Root Superuser Setup" $?
            ;;
        "fix")
            echo -e "${COLORS[GREEN]}Fixing permissions with enhanced safety...${COLORS[NC]}"
            fix_su_permissions && test_result "Permission Fix" $?
            check_accessibility && test_result "Accessibility Check" $?
            ;;
        "backup")
            echo -e "${COLORS[GREEN]}Creating enhanced backup...${COLORS[NC]}"
            backup_critical_files && test_result "Backup Creation" $?
            ;;
        "benchmark")
            echo -e "${COLORS[BLUE]}Running performance benchmark...${COLORS[NC]}"
            benchmark_system_performance
            ;;
        "network")
            echo -e "${COLORS[BLUE]}Running network diagnostics...${COLORS[NC]}"
            check_network_connectivity
            ;;
        "security")
            echo -e "${COLORS[BLUE]}Running security audit...${COLORS[NC]}"
            security_audit
            ;;
        "optimize")
            echo -e "${COLORS[BLUE]}Analyzing system for optimizations...${COLORS[NC]}"
            suggest_optimizations
            ;;
        "full")
            echo -e "${COLORS[GREEN]}Running full diagnostic suite...${COLORS[NC]}"
            check_system_info && test_result "System Info Check" $?
            check_device_compatibility && test_result "Device Compatibility" $?
            check_network_connectivity
            security_audit
            suggest_optimizations
            ;;
        *)
            echo -e "${COLORS[BLUE]}Enhanced Superuser Terminal - Available options:${COLORS[NC]}"
            echo "  check           - Run comprehensive system check (default)"
            echo "  interactive     - Launch interactive mode"
            echo "  setup           - Run initial setup with optimizations"
            echo "  fix             - Fix su permissions with safety checks"
            echo "  backup          - Create enhanced backup of critical files"
            echo "  benchmark       - Run system performance benchmark"
            echo "  network         - Check network connectivity"
            echo "  security        - Run security audit"
            echo "  optimize        - Get optimization suggestions"
            echo "  full            - Run complete diagnostic suite"
            ;;
    esac
    
    local cmd_end
    cmd_end=$(date +%s)
    local total_time
    total_time=$((cmd_end - start_time))
    
    echo -e "${COLORS[BLUE]}Execution completed in ${total_time} seconds${COLORS[NC]}"
    log "INFO" "Enhanced Superuser Terminal session completed (${total_time}s total)"
    log "PERF" "Command '$command' execution took $((cmd_end - cmd_start)) seconds"
    
    return 0
}

# Interactive mode
interactive_mode() {
    while true; do
        echo -e "\n${COLORS[PURPLE]}=== $BRAND_NAME v$VERSION ===${COLORS[NC]}"
        echo "1. Run full system check"
        echo "2. Fix su permissions"
        echo "3. Android command terminal"
        echo "4. Android user info"
        echo "5. Create backup"
        echo "6. View logs"
        echo "7. Exit"
        echo -n "Select option [1-7]: "
        read -r choice
        
        case $choice in
            1)
                echo -e "${COLORS[GREEN]}Running full system check...${COLORS[NC]}"
                check_system_info || true
                check_device_compatibility || true
                setup_root_superuser || true
                fix_su_permissions || true
                check_accessibility || true
                ;;
            2)
                echo -e "${COLORS[GREEN]}Fixing su permissions...${COLORS[NC]}"
                fix_su_permissions || true
                check_accessibility || true
                ;;
            3)
                echo -e "${COLORS[GREEN]}Launching Android terminal...${COLORS[NC]}"
                android_cmd_terminal || true
                ;;
            4)
                echo -e "${COLORS[GREEN]}Getting Android user info...${COLORS[NC]}"
                android_user_info || true
                ;;
            5)
                echo -e "${COLORS[GREEN]}Creating backup...${COLORS[NC]}"
                backup_critical_files || true
                ;;
            6)
                echo -e "${COLORS[CYAN]}Recent log entries:${COLORS[NC]}"
                tail -20 "$LOG_FILE" 2>/dev/null || echo "No logs found"
                ;;
            7)
                echo -e "${COLORS[GREEN]}Goodbye!${COLORS[NC]}"
                break
                ;;
            *)
                echo -e "${COLORS[RED]}Invalid option. Please try again.${COLORS[NC]}"
                ;;
        esac
        
        if [[ $choice != 7 ]]; then
            echo ""
            read -p "Press Enter to continue..."
        fi
    done
}

# Execute main function
main "$@" || {
    echo -e "${COLORS[RED]}Script execution failed.${COLORS[NC]}" >&2
    log "ERROR" "Script execution failed"
    exit 1
}