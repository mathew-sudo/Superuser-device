#!/bin/bash
# Superuser Terminal Script
# Version: 1.0-prototype
# This script provides enhanced functionality for managing superuser access on Android devices.

set -e

# Security hardening - validate execution environment
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    echo "Error: Script must be executed directly, not sourced" >&2
    return 1 2>/dev/null || exit 1
fi

# Input validation function
validate_input() {
    local input="$1"
    local type="${2:-general}"
    
    case "$type" in
        "path")
            if [[ ! "$input" =~ ^[a-zA-Z0-9/_.-]+$ ]]; then
                echo "Error: Invalid path characters detected" >&2
                return 1
            fi
            ;;
        "command")
            if [[ "$input" =~ [;&|`$] ]]; then
                echo "Error: Dangerous command characters detected" >&2
                return 1
            fi
            ;;
        "numeric")
            if [[ "$input" =~ ^[0-9]+$ ]]; then
                return 0
            else
                echo "Error: Non-numeric input detected" >&2
                return 1
            fi
            ;;
    esac
    return 0
}

# Initialize default values for command line arguments with validation
if [[ $# -gt 0 ]]; then
    validate_input "$1" "command" || exit 1
fi
: "${1:=""}"

# Enhanced root check with secure elevation
secure_root_check() {
    # Skip root check if already root or in test mode
    if [ "$(id -u)" -eq 0 ] || [[ "${SKIP_ROOT_CHECK:-0}" == "1" ]] || [[ "${DRY_RUN:-0}" == "1" ]]; then
        return 0
    fi
    
    # Prevent infinite recursion
    if [[ "${ROOT_CHECK_ATTEMPTED:-0}" == "1" ]]; then
        echo "Error: Root check already attempted, avoiding infinite loop" >&2
        exit 1
    fi
    export ROOT_CHECK_ATTEMPTED=1
    
    if [ "$(id -u)" -ne 0 ]; then
        echo "This script must be run as root." >&2
        echo "Attempting secure root elevation..."
        
        # Validate su binary before use
        local su_binary=""
        for potential_su in "/system/bin/su" "/system/xbin/su" "/su/bin/su"; do
            if [[ -f "$potential_su" && -x "$potential_su" ]]; then
                # Additional security check - verify it's a legitimate su binary
                if file "$potential_su" 2>/dev/null | grep -q "executable"; then
                    su_binary="$potential_su"
                    break
                fi
            fi
        done
        
        if [[ -n "$su_binary" ]]; then
            # Secure execution with argument validation
            local safe_args=""
            for arg in "$@"; do
                validate_input "$arg" "command" || exit 1
                safe_args="$safe_args '$arg'"
            done
            exec "$su_binary" -c "$(printf '%q' "$0") $safe_args"
        else
            echo "Error: No valid su binary found" >&2
            if [[ "${TERMUX_ENV:-0}" == "1" ]]; then
                echo "Hint: In Termux, try installing 'tsu' package" >&2
            fi
            exit 1
        fi
    fi
}

# Call secure root check
secure_root_check "$@"

# Confirm root access
echo "Root access confirmed (UID: $(id -u))"

# Version and branding
VERSION="1.0-prototype"
BRAND_NAME="Enhanced Superuser Terminal"

# Logging
LOG_DIR="/data/local/tmp/superuser_logs"
LOG_FILE="$LOG_DIR/superuser_install.log"
MAX_LOGS=12
mkdir -p "$LOG_DIR" 2>/dev/null || {
    echo "Warning: Could not create log directory $LOG_DIR" >&2
    LOG_DIR="/tmp/superuser_logs"
    LOG_FILE="$LOG_DIR/superuser_install.log"
    mkdir -p "$LOG_DIR" 2>/dev/null || {
        echo "Error: Could not create fallback log directory $LOG_DIR" >&2
        exit 1
    }
}

# Enhanced logging function with error handling
log() {
    local level="${1:-INFO}"
    shift || true
    local message="${*:-No message provided}"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown-time")
    
    # Ensure log directory exists
    if [ ! -d "$LOG_DIR" ]; then
        mkdir -p "$LOG_DIR" 2>/dev/null || {
            echo "Warning: Could not create log directory $LOG_DIR" >&2
            return 1
        }
    fi
    
    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE" 2>/dev/null || {
        echo "[$timestamp] [$level] $message"
        echo "Warning: Could not write to log file $LOG_FILE" >&2
    }
}

# Rotate logs if needed
if [ $(ls "$LOG_DIR"/*.log 2>/dev/null | wc -l) -ge $MAX_LOGS ]; then
    rm "$(ls -t "$LOG_DIR"/*.log | tail -1)"
fi

# Improved color array (declare -A for associative array)
declare -A COLORS=(
    [RED]='\033[0;31m'
    [GREEN]='\033[0;32m'
    [CYAN]='\033[0;36m'
    [YELLOW]='\033[1;33m'
    [BLUE]='\033[0;34m'
    [PURPLE]='\033[0;35m'
    [NC]='\033[0m'
)

# Enhanced dependency checker with better error handling
check_dependencies() {
    echo -e "${COLORS[CYAN]}Checking system dependencies...${COLORS[NC]}"
    log "INFO" "Starting dependency check"
    
    local missing_deps=()
    local required_commands=("stat" "chmod" "chown" "mkdir" "grep" "awk" "date")
    local optional_commands=("df" "uname" "cut" "head" "tail" "file" "timeout" "getenforce" "busybox" "adb" "magisk" "su" "id" "tsu")

    # Check required commands
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing_deps+=("$cmd")
            echo -e "${COLORS[RED]}✗${COLORS[NC]} Missing required command: $cmd"
        else
            echo -e "${COLORS[GREEN]}✓${COLORS[NC]} Found: $cmd"
        fi
    done
    
    # Check optional commands
    for cmd in "${optional_commands[@]}"; do
        if command -v "$cmd" >/dev/null 2>&1; then
            echo -e "${COLORS[GREEN]}✓${COLORS[NC]} Found (optional): $cmd"
        else
            echo -e "${COLORS[YELLOW]}!${COLORS[NC]} Missing (optional): $cmd"
        fi
    done
    
    # Handle missing dependencies gracefully
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo -e "${COLORS[YELLOW]}Attempting to resolve missing dependencies...${COLORS[NC]}"
        if command -v busybox >/dev/null 2>&1; then
            echo -e "${COLORS[GREEN]}BusyBox detected - using built-in commands${COLORS[NC]}"
            # Create symlinks for missing commands if busybox is available
            for dep in "${missing_deps[@]}"; do
                if busybox "$dep" --help >/dev/null 2>&1; then
                    # Only create symlinks if we have write access
                    if [[ -w "/system/bin" ]] 2>/dev/null; then
                        ln -sf "$(which busybox)" "/system/bin/$dep" 2>/dev/null || true
                    fi
                fi
            done
        else
            echo -e "${COLORS[RED]}Critical dependencies missing and no BusyBox available${COLORS[NC]}"
            log "ERROR" "Missing critical dependencies: ${missing_deps[*]}"
            echo -e "${COLORS[YELLOW]}Continuing with limited functionality...${COLORS[NC]}"
            return 1
        fi
    fi
    
    echo -e "${COLORS[GREEN]}Dependency check completed${COLORS[NC]}"
    log "INFO" "Dependency check completed"
    return 0
}

# System information check
check_system_info() {
    echo -e "${COLORS[CYAN]}System Information Check:${COLORS[NC]}"
    log "INFO" "Starting system information check"
    
    # Enhanced Android version detection with multiple sources
    local android_version="Unknown"
    local api_level="Unknown"
    
    # Try multiple sources for Android version
    if [[ -f "/system/build.prop" ]]; then
        android_version=$(grep "ro.build.version.release" /system/build.prop 2>/dev/null | cut -d'=' -f2 | head -1 || echo "Unknown")
        api_level=$(grep "ro.build.version.sdk" /system/build.prop 2>/dev/null | cut -d'=' -f2 | head -1 || echo "Unknown")
    elif [[ -f "/vendor/build.prop" ]]; then
        android_version=$(grep "ro.vendor.build.version.release" /vendor/build.prop 2>/dev/null | cut -d'=' -f2 | head -1 || echo "Unknown")
    fi
    
    # Validate extracted values
    if [[ "$api_level" =~ ^[0-9]+$ ]]; then
        validate_input "$api_level" "numeric" || api_level="Unknown"
    fi
    
    echo -e "${COLORS[GREEN]}Android Version: $android_version (API $api_level)${COLORS[NC]}"
    log "INFO" "Android Version: $android_version (API $api_level)"
    
    # Enhanced architecture detection
    arch=$(uname -m 2>/dev/null || echo "unknown")
    local cpu_abi=""
    if [[ -f "/system/build.prop" ]]; then
        cpu_abi=$(grep "ro.product.cpu.abi=" /system/build.prop 2>/dev/null | cut -d'=' -f2 || echo "")
    fi
    
    echo -e "${COLORS[GREEN]}Architecture: $arch${COLORS[NC]}"
    if [[ -n "$cpu_abi" ]]; then
        echo -e "${COLORS[GREEN]}CPU ABI: $cpu_abi${COLORS[NC]}"
        log "INFO" "Architecture: $arch, CPU ABI: $cpu_abi"
    else
        log "INFO" "Architecture: $arch"
    fi
    
    # Check available space with error handling
    if available_space=$(df /data 2>/dev/null | tail -1 | awk '{print $4}'); then
        echo -e "${COLORS[GREEN]}Available space in /data: ${available_space}KB${COLORS[NC]}"
        log "INFO" "Available space in /data: ${available_space}KB"
    else
        echo -e "${COLORS[YELLOW]}Warning: Could not check available space in /data${COLORS[NC]}"
        log "WARN" "Could not check /data space"
    fi
    
    # Check SELinux status
    if command -v getenforce >/dev/null 2>&1; then
        selinux_status=$(getenforce 2>/dev/null || echo "Unknown")
        echo -e "${COLORS[YELLOW]}SELinux Status: $selinux_status${COLORS[NC]}"
        log "INFO" "SELinux Status: $selinux_status"
    else
        echo -e "${COLORS[YELLOW]}SELinux tools not available${COLORS[NC]}"
        log "INFO" "SELinux tools not available"
    fi
}

# Enhanced device compatibility check
check_device_compatibility() {
    echo -e "${COLORS[CYAN]}Device Compatibility Check:${COLORS[NC]}"
    log "INFO" "Starting device compatibility check"
    
    local compatibility_score=0
    local total_checks=0
    
    # Check for root access indicators
    local root_indicators=(
        "/system/app/Superuser.apk"
        "/system/etc/init.d"
        "/system/bin/busybox"
        "/data/local/tmp"
    )
    
    for indicator in "${root_indicators[@]}"; do
        ((total_checks++))
        if [ -e "$indicator" ]; then
            echo -e "${COLORS[GREEN]}✓${COLORS[NC]} Found: $indicator"
            ((compatibility_score++))
        else
            echo -e "${COLORS[RED]}✗${COLORS[NC]} Missing: $indicator"
        fi
    done
    
    # Calculate compatibility percentage
    local compatibility_percent=$((compatibility_score * 100 / total_checks))
    echo -e "${COLORS[BLUE]}Compatibility Score: $compatibility_percent%${COLORS[NC]}"
    log "INFO" "Device compatibility score: $compatibility_percent%"
    
    if [ $compatibility_percent -lt 50 ]; then
        echo -e "${COLORS[RED]}Warning: Low compatibility detected. Proceed with caution.${COLORS[NC]}"
        log "WARN" "Low compatibility detected"
    fi
}

# List of su binary locations
SU_PATHS=(
    "/system/bin/su" "/system/xbin/su" "/sbin/su" "/su/bin/su" "/su/xbin/su" "/system/sbin/su" "/magisk/.core/bin/su" "/debug_ramdisk/su" "/sbin/bin/su" "/system/su" "/system/xbin/daemonsu" "/system/xbin/busybox" "/su" "/xbin/su" "/bin/su" "/0/su"
)

# Setup root superuser directories and permissions
setup_root_superuser() {
    local root_dirs=(
        "/data/superuser"
        "/data/superuser/bin"
        "/data/superuser/etc"
        "/data/superuser/lib"
        "/data/superuser/tmp"
    )
    for dir in "${root_dirs[@]}"; do
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir"
            echo -e "${COLORS[YELLOW]}Created $dir${COLORS[NC]}"
        fi
        chmod 700 "$dir"
        chown root:root "$dir"
    done
    cat > /data/superuser/etc/profile << EOF
export PATH="/data/superuser/bin:$PATH"
export SUPERUSER_HOME="/data/superuser"
PS1='root@superuser:\w# '
EOF
}

# Enhanced su permissions fix with safety checks
fix_su_permissions() {
    echo -e "${COLORS[CYAN]}Fixing su binary permissions...${COLORS[NC]}"
    log "INFO" "Starting su permissions fix"
    
    local fixed_count=0
    local total_found=0
    local failed_paths=()
    
    for su_path in "${SU_PATHS[@]}"; do
        # Validate path before processing
        validate_input "$su_path" "path" || continue
        
        if [[ -f "$su_path" ]]; then
            ((total_found++))
            
            # Enhanced safety checks
            local file_type=""
            if command -v file >/dev/null 2>&1; then
                file_type=$(file "$su_path" 2>/dev/null || echo "")
            fi
            
            # Verify it's an executable and not a script
            if [[ "$file_type" =~ (executable|ELF) ]] || [[ -x "$su_path" ]]; then
                # Create timestamped backup
                local backup_dir="/data/superuser/backup"
                mkdir -p "$backup_dir" 2>/dev/null || {
                    log "WARN" "Could not create backup directory"
                    continue
                }
                
                local backup_name="$backup_dir/$(basename "$su_path").backup.$(date +%s)"
                if cp "$su_path" "$backup_name" 2>/dev/null; then
                    log "INFO" "Created backup: $backup_name"
                else
                    log "WARN" "Could not create backup for $su_path"
                fi
                
                # Apply permissions with error handling
                local success=true
                chmod 6755 "$su_path" 2>/dev/null || {
                    echo -e "${COLORS[RED]}Failed to set permissions for $su_path${COLORS[NC]}"
                    log "ERROR" "chmod failed for $su_path"
                    failed_paths+=("$su_path")
                    success=false
                }
                
                chown root:root "$su_path" 2>/dev/null || {
                    echo -e "${COLORS[RED]}Failed to set ownership for $su_path${COLORS[NC]}"
                    log "ERROR" "chown failed for $su_path"
                    if [[ "$success" == "true" ]]; then
                        failed_paths+=("$su_path")
                        success=false
                    fi
                }
                
                if [[ "$success" == "true" ]]; then
                    echo -e "${COLORS[GREEN]}Fixed permissions for $su_path${COLORS[NC]}"
                    log "INFO" "Fixed permissions for $su_path"
                    ((fixed_count++))
                fi
            else
                echo -e "${COLORS[YELLOW]}Skipping $su_path (not a valid executable)${COLORS[NC]}"
                log "WARN" "Skipped $su_path - not a valid executable"
            fi
        fi
    done
    
    echo -e "${COLORS[BLUE]}Summary: Fixed $fixed_count out of $total_found su binaries${COLORS[NC]}"
    log "INFO" "Su permissions fix completed: $fixed_count/$total_found"
    
    # Report failures and suggest recovery
    if [[ ${#failed_paths[@]} -gt 0 ]]; then
        echo -e "${COLORS[YELLOW]}Failed to fix permissions for:${COLORS[NC]}"
        for path in "${failed_paths[@]}"; do
            echo -e "${COLORS[RED]}  - $path${COLORS[NC]}"
        done
        echo -e "${COLORS[CYAN]}Recovery suggestions:${COLORS[NC]}"
        echo "  - Check if filesystem is mounted read-only"
        echo "  - Verify SELinux policy allows modifications"
        echo "  - Ensure sufficient disk space"
        return 1
    fi
    
    return 0
}

# Enhanced backup function
backup_critical_files() {
    echo -e "${COLORS[CYAN]}Creating backup of critical files...${COLORS[NC]}"
    local backup_dir="/data/superuser/backup/$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup_dir"
    
    for su_path in "${SU_PATHS[@]}"; do
        if [ -f "$su_path" ]; then
            cp "$su_path" "$backup_dir/" 2>/dev/null && \
            echo -e "${COLORS[GREEN]}Backed up: $su_path${COLORS[NC]}" || \
            echo -e "${COLORS[RED]}Failed to backup: $su_path${COLORS[NC]}"
        fi
    done
    
    echo -e "${COLORS[BLUE]}Backup location: $backup_dir${COLORS[NC]}"
    log "INFO" "Backup created at: $backup_dir"
}

# Improved accessibility check: also test execution
check_accessibility() {
    echo -e "${COLORS[CYAN]}\nAccessibility Check Summary:${COLORS[NC]}"
    log "INFO" "Starting accessibility check"
    local all_ok=1
    local found_count=0
    local working_count=0
    local issues=()
    
    for su_path in "${SU_PATHS[@]}"; do
        validate_input "$su_path" "path" || continue
        
        if [[ -f "$su_path" ]]; then
            ((found_count++))
            local perms=$(stat -c %a "$su_path" 2>/dev/null || echo "000")
            local owner=$(stat -c %U "$su_path" 2>/dev/null || echo "unknown")
            local group=$(stat -c %G "$su_path" 2>/dev/null || echo "unknown")
            
            if [[ "$perms" == "6755" && "$owner" == "root" && "$group" == "root" ]]; then
                # Enhanced executable test with timeout and error capture
                local test_result=""
                if command -v timeout >/dev/null 2>&1; then
                    test_result=$(timeout 5 "$su_path" --version 2>&1 || timeout 5 "$su_path" -c "id" 2>&1 || echo "failed")
                else
                    # Fallback without timeout
                    test_result=$("$su_path" --version 2>&1 || "$su_path" -c "id" 2>&1 || echo "failed")
                fi
                
                if [[ "$test_result" != "failed" && ! "$test_result" =~ (not found|denied|invalid) ]]; then
                    echo -e "${COLORS[GREEN]}OK${COLORS[NC]} $su_path (6755 root:root, executable)"
                    ((working_count++))
                    log "INFO" "Su binary working: $su_path"
                else
                    echo -e "${COLORS[YELLOW]}WARN${COLORS[NC]} $su_path (permissions OK, execution failed: ${test_result:0:50})"
                    issues+=("$su_path: execution failed")
                    all_ok=0
                    log "WARN" "Su binary not executable: $su_path - $test_result"
                fi
            else
                echo -e "${COLORS[RED]}BAD${COLORS[NC]} $su_path (perms: $perms, owner: $owner:$group)"
                issues+=("$su_path: incorrect permissions/ownership")
                all_ok=0
                log "ERROR" "Su binary bad permissions: $su_path"
            fi
        fi
    done
    
    echo -e "${COLORS[BLUE]}Summary: Found $found_count su binaries, $working_count working${COLORS[NC]}"
    
    # Check root superuser dir
    if [ -d "/data/superuser" ]; then
        perms=$(stat -c %a /data/superuser)
        owner=$(stat -c %U /data/superuser)
        group=$(stat -c %G /data/superuser)
        if [ "$perms" = "700" ] && [ "$owner" = "root" ] && [ "$group" = "root" ]; then
            echo -e "${COLORS[GREEN]}OK${COLORS[NC]} /data/superuser (700 root:root)"
        else
            echo -e "${COLORS[RED]}BAD${COLORS[NC]} /data/superuser (perms: $perms, owner: $owner:$group)"
            all_ok=0
        fi
    else
        echo -e "${COLORS[RED]}MISSING${COLORS[NC]} /data/superuser"
        all_ok=0
    fi
    
    # Enhanced diagnostics for issues
    if [[ ${#issues[@]} -gt 0 ]]; then
        echo -e "${COLORS[YELLOW]}Detected Issues:${COLORS[NC]}"
        for issue in "${issues[@]}"; do
            echo -e "${COLORS[RED]}  - $issue${COLORS[NC]}"
        done
        echo -e "${COLORS[CYAN]}Troubleshooting suggestions:${COLORS[NC]}"
        echo "  - Run 'setenforce 0' to temporarily disable SELinux"
        echo "  - Check mount options: 'mount | grep system'"
        echo "  - Verify root access: 'id'"
        echo "  - Check for Magisk/SuperSU conflicts"
    fi
    
    if [[ $all_ok -eq 1 ]]; then
        echo -e "${COLORS[GREEN]}All checks passed!${COLORS[NC]}"
        log "INFO" "All accessibility checks passed"
    else
        echo -e "${COLORS[RED]}Some issues detected. Please review above.${COLORS[NC]}"
        log "ERROR" "Accessibility check failed"
    fi
    
    return $all_ok
}

# Auto-install adb if missing
install_adb_if_missing() {
    if ! command -v adb >/dev/null 2>&1; then
        echo -e "${COLORS[YELLOW]}adb not found. Attempting to install Android Platform Tools...${COLORS[NC]}"
        if command -v apt-get >/dev/null 2>&1; then
            apt-get update && apt-get install -y android-tools-adb && echo -e "${COLORS[GREEN]}adb installed.${COLORS[NC]}"
        elif command -v yum >/dev/null 2>&1; then
            yum install -y android-tools && echo -e "${COLORS[GREEN]}adb installed.${COLORS[NC]}"
        else
            echo -e "${COLORS[RED]}Could not auto-install adb. Please install it manually.${COLORS[NC]}"
        fi
    fi
}

# Android command terminal function
android_cmd_terminal() {
    install_adb_if_missing
    echo -e "${COLORS[CYAN]}Launching Android command terminal...${COLORS[NC]}"
    
    if ! command -v adb >/dev/null 2>&1; then
        echo -e "${COLORS[RED]}adb not found. Please install Android Platform Tools.${COLORS[NC]}"
        return 1
    fi
    
    # Start adb server
    if adb start-server >/dev/null 2>&1; then
        echo -e "${COLORS[GREEN]}adb server started.${COLORS[NC]}"
    else
        echo -e "${COLORS[YELLOW]}adb server already running or failed to start.${COLORS[NC]}"
    fi
    
    # Check device connection
    local device=$(adb get-state 2>/dev/null || echo "unknown")
    if [[ "$device" == "device" ]]; then
        echo -e "${COLORS[GREEN]}Connected to device: $device${COLORS[NC]}"
    else
        echo -e "${COLORS[RED]}No device connected or authorized.${COLORS[NC]}"
        echo -e "${COLORS[YELLOW]}Please connect your device and enable USB debugging.${COLORS[NC]}"
        return 1
    fi
    
    # Launch adb shell
    echo -e "${COLORS[CYAN]}Opening adb shell...${COLORS[NC]}"
    echo -e "${COLORS[CYAN]}You are now in the adb shell. Type 'exit' to return.${COLORS[NC]}"
    
    adb shell || {
        echo -e "${COLORS[RED]}Failed to open adb shell. Is your device connected and authorized?${COLORS[NC]}"
        return 1
    }
    
    echo -e "${COLORS[GREEN]}adb shell session ended.${COLORS[NC]}"
}

# Android user account and id info
android_user_info() {
    install_adb_if_missing
    echo -e "${COLORS[CYAN]}Android User Account & ID Info:${COLORS[NC]}"
    if ! command -v adb >/dev/null 2>&1; then
        echo -e "${COLORS[RED]}adb not found. Please install Android Platform Tools.${COLORS[NC]}"
        return 1
    fi
    adb start-server >/dev/null 2>&1
    adb shell 'pm list users; id; whoami; getprop persist.sys.device_name; getprop ro.product.model; getprop ro.serialno' 2>/dev/null || {
        echo -e "${COLORS[RED]}Failed to retrieve user info. Is your device connected and authorized?${COLORS[NC]}"
        return 1
    }
}

# Auto-configure sudo/root superuser if possible
auto_configure_sudo() {
    echo -e "${COLORS[CYAN]}Checking sudo/root superuser configuration...${COLORS[NC]}"
    # Check if sudo is installed
    if ! command -v sudo >/dev/null 2>&1; then
        echo -e "${COLORS[YELLOW]}sudo not found. Attempting to install...${COLORS[NC]}"
        if command -v apt-get >/dev/null 2>&1; then
            apt-get update && apt-get install -y sudo && echo -e "${COLORS[GREEN]}sudo installed.${COLORS[NC]}"
        elif command -v yum >/dev/null 2>&1; then
            yum install -y sudo && echo -e "${COLORS[GREEN]}sudo installed.${COLORS[NC]}"
        else
            echo -e "${COLORS[RED]}Could not auto-install sudo. Please install it manually.${COLORS[NC]}"
        fi
    else
        echo -e "${COLORS[GREEN]}sudo is present.${COLORS[NC]}"
    fi
    # Ensure current user is in sudoers if not root
    if [ "$(id -u)" -ne 0 ]; then
        user=$(whoami)
        if sudo -l -U "$user" | grep -q '(ALL) ALL'; then
            echo -e "${COLORS[GREEN]}$user already has sudo privileges.${COLORS[NC]}"
        else
            echo -e "${COLORS[YELLOW]}$user does not have sudo privileges. Attempting to add...${COLORS[NC]}"
            echo "$user ALL=(ALL) NOPASSWD:ALL" | sudo tee /etc/sudoers.d/$user >/dev/null && \
            echo -e "${COLORS[GREEN]}$user added to sudoers (NOPASSWD).${COLORS[NC]}"
        fi
    fi
}

# Test sudo/root superuser access
check_sudo_root_access() {
    echo -e "${COLORS[CYAN]}Testing sudo/root superuser access...${COLORS[NC]}"
    if [ "$(id -u)" -eq 0 ]; then
        echo -e "${COLORS[GREEN]}Already running as root.${COLORS[NC]}"
    else
        if sudo -n true 2>/dev/null; then
            echo -e "${COLORS[GREEN]}Sudo access confirmed for $(whoami).${COLORS[NC]}"
        else
            echo -e "${COLORS[RED]}Sudo access failed for $(whoami).${COLORS[NC]}"
        fi
    fi
}

# Detect Termux environment
detect_termux() {
    if [[ -d "/data/data/com.termux" ]] || [[ -n "${TERMUX_VERSION:-}" ]] || [[ "${PREFIX:-}" == *"com.termux"* ]]; then
        export TERMUX_ENV=1
        export PREFIX="${PREFIX:-/data/data/com.termux/files/usr}"
        export TERMUX_HOME="${TERMUX_HOME:-/data/data/com.termux/files/home}"
        
        log "INFO" "Termux environment detected"
        echo -e "${COLORS[YELLOW]}🔧 Termux Environment Detected${COLORS[NC]}"
        return 0
    fi
    return 1
}

# Termux integration features
termux_integration() {
    if [[ "${TERMUX_ENV}" == "1" ]]; then
        log "INFO" "Enabling Termux integration features"
        
        # Termux API integration
        if command -v termux-notification >/dev/null 2>&1; then
            termux-notification --title "Superuser Terminal" --content "Root access session started" 2>/dev/null || true
        fi
        
        # Storage access check
        if [[ ! -d "/storage" && ! -d "$HOME/storage" ]]; then
            log "WARN" "Storage access not configured. Run: termux-setup-storage"
            echo -e "${COLORS[YELLOW]}⚠️ Storage access not configured. Run: termux-setup-storage${COLORS[NC]}"
        fi
        
        # Set Termux-specific environment
        export TERMUX_APP_PACKAGE="com.termux"
        export SHELL="${PREFIX}/bin/bash"
        
        # Create Termux-specific directories
        mkdir -p "$TERMUX_HOME/.config" "$TERMUX_HOME/.local/share" 2>/dev/null || true
    fi
}

# Termux interactive mode
termux_interactive_mode() {
    while true; do
        clear
        echo -e "${COLORS[PURPLE]}╔══════════════════════════════════════════════════════╗${COLORS[NC]}"
        echo -e "${COLORS[PURPLE]}║     🔐 ENHANCED SUPERUSER TERMINAL - TERMUX 🔐       ║${COLORS[NC]}"
        echo -e "${COLORS[PURPLE]}║                   v$VERSION                           ║${COLORS[NC]}"
        echo -e "${COLORS[PURPLE]}╚══════════════════════════════════════════════════════╝${COLORS[NC]}"
        echo ""
        echo -e "${COLORS[CYAN]}📱 ANDROID OPERATIONS:${COLORS[NC]}"
        echo "1. 🔍 Full system check"
        echo "2. 🔧 Fix su permissions"
        echo "3. 📱 Android terminal"
        echo "4. 📊 Device information"
        echo "5. 💾 Create backup"
        echo ""
        echo -e "${COLORS[CYAN]}🛠️ TERMUX TOOLS:${COLORS[NC]}"
        echo "6. 🖥️ Launch GUI (VNC)"
        echo "7. 🔧 Termux tools menu"
        echo "8. 📝 View logs"
        echo "9. ⚙️ System configuration"
        echo ""
        echo "0. ❌ Exit"
        echo ""
        echo -n "Select option [0-9]: "
        read -r choice
        
        case $choice in
            1)
                echo -e "${COLORS[GREEN]}Running full system check...${COLORS[NC]}"
                check_system_info || true
                check_device_compatibility || true
                setup_root_superuser || true
                fix_su_permissions || true
                check_accessibility || true
                ;;
            2)
                echo -e "${COLORS[GREEN]}Fixing permissions...${COLORS[NC]}"
                fix_su_permissions || true
                check_accessibility || true
                ;;
            3)
                android_cmd_terminal || true
                ;;
            4)
                android_user_info || true
                if command -v termux-telephony-deviceinfo >/dev/null 2>&1; then
                    echo -e "${COLORS[CYAN]}Termux Device Info:${COLORS[NC]}"
                    termux-telephony-deviceinfo 2>/dev/null || echo "Device info not available"
                fi
                ;;
            5)
                backup_critical_files || true
                ;;
            6)
                if command -v vncserver >/dev/null 2>&1; then
                    echo -e "${COLORS[GREEN]}🖥️ Starting VNC server...${COLORS[NC]}"
                    vncserver :1 -geometry 1280x720 2>/dev/null || echo "VNC start failed"
                    echo "Connect VNC client to localhost:5901"
                else
                    echo -e "${COLORS[RED]}VNC server not installed${COLORS[NC]}"
                    echo "Install with: pkg install tigervnc"
                fi
                ;;
            7)
                termux_tools_menu || echo "Tools menu not available"
                ;;
            8)
                echo -e "${COLORS[CYAN]}Recent log entries:${COLORS[NC]}"
                tail -20 "$LOG_FILE" 2>/dev/null || echo "No logs found"
                ;;
            9)
                termux_system_config || echo "System config not available"
                ;;
            0)
                echo -e "${COLORS[GREEN]}👋 Goodbye from Termux!${COLORS[NC]}"
                if command -v termux-notification >/dev/null 2>&1; then
                    termux-notification --title "Superuser Terminal" --content "Session ended" 2>/dev/null || true
                fi
                break
                ;;
            *)
                echo -e "${COLORS[RED]}❌ Invalid option. Please try again.${COLORS[NC]}"
                sleep 1
                ;;
        esac
        
        if [[ $choice != 0 ]]; then
            echo ""
            read -p "Press Enter to continue..."
        fi
    done
}

# Termux tools menu
termux_tools_menu() {
    echo -e "${COLORS[CYAN]}🔧 Termux Tools Menu:${COLORS[NC]}"
    echo "1. Package manager (pkg)"
    echo "2. Setup storage access"
    echo "3. Install development tools"
    echo "4. Network tools"
    echo "5. Back to main menu"
    echo -n "Select option [1-5]: "
    read -r tool_choice
    
    case $tool_choice in
        1)
            echo -e "${COLORS[GREEN]}Opening package manager...${COLORS[NC]}"
            pkg list-installed | head -20
            echo "Use 'pkg install <package>' to install new packages"
            ;;
        2)
            echo -e "${COLORS[GREEN]}Setting up storage access...${COLORS[NC]}"
            termux-setup-storage || echo "termux-setup-storage not available"
            ;;
        3)
            echo -e "${COLORS[GREEN]}Installing development tools...${COLORS[NC]}"
            pkg install -y git make clang python nodejs || echo "Installation failed"
            ;;
        4)
            echo -e "${COLORS[GREEN]}Network tools available:${COLORS[NC]}"
            echo "- curl, wget: Download tools"
            echo "- openssh: SSH client/server"
            echo "- nmap: Network scanner"
            ;;
        5)
            return 0
            ;;
        *)
            echo -e "${COLORS[RED]}Invalid option${COLORS[NC]}"
            ;;
    esac
}

# Termux system configuration
termux_system_config() {
    echo -e "${COLORS[CYAN]}📋 Termux System Configuration:${COLORS[NC]}"
    echo "Termux prefix: ${PREFIX:-Not set}"
    echo "Termux home: ${TERMUX_HOME:-Not set}"
    echo "Storage access: $(test -d /storage && echo "✅ Available" || echo "❌ Run termux-setup-storage")"
    echo "Root access: $(test "$(id -u)" -eq 0 && echo "✅ Active" || echo "❌ Not root")"
    echo "TSU available: $(command -v tsu >/dev/null && echo "✅ Yes" || echo "❌ No")"
    echo "Python: $(python3 --version 2>/dev/null || echo "Not installed")"
    echo "Git: $(git --version 2>/dev/null || echo "Not installed")"
    echo "Node.js: $(node --version 2>/dev/null || echo "Not installed")"
}

# Test result function for CI compatibility
test_result() {
    local test_name="$1"
    local result="$2"
    
    if [[ "$result" -eq 0 ]]; then
        echo -e "${COLORS[GREEN]}✓ ${test_name}${COLORS[NC]}"
        log "INFO" "$test_name passed"
        return 0
    else
        echo -e "${COLORS[RED]}✗ ${test_name}${COLORS[NC]}"
        log "ERROR" "$test_name failed with exit code $result"
        return 1
    fi
}

# Create directories function for CI compatibility
create_directories() {
    echo -e "${COLORS[CYAN]}Creating required directories...${COLORS[NC]}"
    
    # Create GitHub workflows directory
    mkdir -p .github/workflows logs backups || {
        echo -e "${COLORS[RED]}Error: Failed to create directories${COLORS[NC]}" >&2
        return 1
    }
    
    # Move CI test file if it exists in wrong location
    if [[ -f "superuser.test" ]]; then
        echo -e "${COLORS[YELLOW]}Moving CI test file to correct location...${COLORS[NC]}"
        mv superuser.test .github/workflows/ci.yml || {
            echo -e "${COLORS[RED]}Error: Failed to move CI file${COLORS[NC]}" >&2
            return 1
        }
    fi
    
    # Create .gitignore if missing
    if [[ ! -f ".gitignore" ]]; then
        echo -e "${COLORS[CYAN]}Creating .gitignore...${COLORS[NC]}"
        cat > .gitignore << 'EOF'
# Logs
logs/
*.log

# Backups
backups/
*.backup

# Temporary files
*.tmp
*.swp
*.bak

# IDE files
.vscode/
.idea/

# OS files
.DS_Store
Thumbs.db

# Python cache
__pycache__/
*.pyc
*.pyo

# Node modules
node_modules/

# Build artifacts
*.o
*.so
*.exe
*.out
EOF
    fi
    
    echo -e "${COLORS[GREEN]}✓ All directories created successfully${COLORS[NC]}"
    return 0
}

# Enhanced main function with all required integrations
main() {
    # Detect Termux environment first
    detect_termux || true
    
    echo -e "${COLORS[CYAN]}$BRAND_NAME v$VERSION${COLORS[NC]}"
    if [[ "${TERMUX_ENV}" == "1" ]]; then
        echo -e "${COLORS[YELLOW]}🔧 Termux Environment Detected${COLORS[NC]}"
    fi
    
    log "INFO" "Starting Enhanced Superuser Terminal v$VERSION"
    
    # Enable Termux integration if detected
    if [[ "${TERMUX_ENV}" == "1" ]]; then
        termux_integration || {
            log "WARN" "Termux integration had issues"
            echo -e "${COLORS[YELLOW]}Warning: Termux integration incomplete${COLORS[NC]}"
        }
    fi
    
    # Check dependencies with better error handling
    check_dependencies || {
        echo -e "${COLORS[YELLOW]}Continuing with limited functionality...${COLORS[NC]}"
        log "WARN" "Dependency check failed - limited functionality"
    }
    
    # Handle command line arguments
    local command="${1:-check}"
    
    case "$command" in
        "interactive"|"-i")
            if [[ "${TERMUX_ENV}" == "1" ]]; then
                termux_interactive_mode
            else
                interactive_mode
            fi
            ;;
        "check")
            echo -e "${COLORS[GREEN]}Running system check...${COLORS[NC]}"
            check_system_info && test_result "System Info Check" $?
            check_device_compatibility && test_result "Device Compatibility" $?
            echo -e "${COLORS[GREEN]}System check completed.${COLORS[NC]}"
            ;;
        "setup")
            echo -e "${COLORS[GREEN]}Running setup...${COLORS[NC]}"
            create_directories && test_result "Directory Creation" $?
            setup_root_superuser && test_result "Root Superuser Setup" $?
            ;;
        "fix")
            echo -e "${COLORS[GREEN]}Fixing permissions...${COLORS[NC]}"
            fix_su_permissions && test_result "Permission Fix" $?
            check_accessibility && test_result "Accessibility Check" $?
            ;;
        "backup")
            echo -e "${COLORS[GREEN]}Creating backup...${COLORS[NC]}"
            backup_critical_files && test_result "Backup Creation" $?
            ;;
        *)
            echo -e "${COLORS[BLUE]}Available options:${COLORS[NC]}"
            echo "  check           - Run system check (default)"
            echo "  interactive     - Launch interactive mode"
            echo "  setup           - Run initial setup"
            echo "  fix             - Fix su permissions"
            echo "  backup          - Create backup of critical files"
            ;;
    esac
    
    log "INFO" "Enhanced Superuser Terminal session completed"
    return 0
}

# Execute main function
main "$@" || {
    echo -e "${COLORS[RED]}Script execution failed.${COLORS[NC]}" >&2
    log "ERROR" "Script execution failed"
    exit 1
}